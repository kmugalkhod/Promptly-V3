/**
 * Auto-generated skills bundle — DO NOT EDIT MANUALLY
 *
 * Generated by: npx tsx scripts/bundle-skills.ts
 * Generated at: 2026-02-22T11:03:28.466Z
 * Skills count: 28
 *
 * This file embeds all SKILL.md content so skills are available
 * in environments without filesystem access (e.g., Convex cloud).
 */

export interface BundledSkill {
  name: string;
  description: string;
  category: string;
  agents: string[];
  instructions: string;
}

export const SKILLS_BUNDLE: Record<string, BundledSkill> = {
  "add-feature": {
    name: "add-feature",
    description: "Add new functionality to existing code. Use when user requests new components, features, interactions, or capabilities.",
    category: "chat",
    agents: ["chat"],
    instructions: "## When to Use\r\n- User asks to \"add\", \"create\", \"implement\" something new\r\n- Adding new components or sections\r\n- Adding new interactions (modals, toggles, forms)\r\n- Adding data fetching or state management\r\n\r\n## Instructions\r\n\r\n### Feature Addition Workflow\r\n\r\n1. **Read existing code** — understand current structure before adding\r\n2. **Plan where to add** — new file or extend existing file?\r\n3. **Follow existing patterns** — match the codebase style\r\n4. **Add imports** — only add what's needed\r\n5. **Integrate with existing code** — connect to parent, add to layout\r\n\r\n### Decision: New File vs Existing File\r\n\r\n| Scenario | Action |\r\n|----------|--------|\r\n| New section/component | Create new file in `components/` |\r\n| New page | Create new file in `app/page-name/page.tsx` |\r\n| Add to existing section | Modify existing component file |\r\n| New utility function | Add to existing `lib/` file or create new |\r\n| New type | Add to existing `types/index.ts` |\r\n\r\n### Integration Checklist\r\n\r\n- [ ] New component imported in parent\r\n- [ ] New component rendered in correct position\r\n- [ ] Props passed from parent to child\r\n- [ ] 'use client' added if using hooks/events\r\n- [ ] TypeScript interfaces defined for new props\r\n- [ ] CSS variables used for colors (no hardcoded hex)\r\n- [ ] Responsive design considered (mobile-first)\r\n\r\n### State Management for New Features\r\n\r\n- **Simple state**: `useState` in the component\r\n- **Shared state**: Lift state to common parent\r\n- **Complex state**: `useReducer` for state machines\r\n- **NEVER** use `useSyncExternalStore` — use useState or Context\r\n\r\n### Protected Files\r\n\r\nWhen adding features, NEVER modify:\r\n- tailwind.config.ts / .js\r\n- postcss.config.js / .mjs\r\n- next.config.js / .mjs / .ts\r\n- package.json — use install_packages tool instead\r\n- tsconfig.json\r\n- lib/utils.ts",
  },
  "animation": {
    name: "animation",
    description: "Add motion and transitions to components. Use when implementing hover effects, page transitions, or micro-interactions. Match motion_level from architecture.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Adding hover effects to cards/buttons\r\n- Creating page or section transitions\r\n- Building micro-interactions\r\n- When architecture specifies motion_level\r\n\r\n## Instructions\r\n\r\n### Motion Levels Reference\r\n\r\nMatch the `motion_level` from architecture.md DESIGN_DIRECTION:\r\n\r\n| Level | Transition | Hover Effect | Use Case |\r\n|-------|------------|--------------|----------|\r\n| none | `transition-none` | No effect | Print-like, static aesthetic |\r\n| subtle | `transition-all duration-200` | `hover:translate-y-[-1px] hover:shadow-sm` | Professional, minimal |\r\n| expressive | `transition-all duration-300` | `hover:translate-y-[-4px] hover:shadow-lg hover:scale-[1.02]` | Modern SaaS, playful |\r\n| dramatic | `transition-all duration-500` | `hover:translate-y-[-8px] hover:shadow-2xl hover:scale-105 hover:rotate-1` | Bold, theatrical |\r\n\r\n### Basic Transition Patterns\r\n\r\n```tsx\r\n// Subtle - barely perceptible\r\n<button className=\"transition-all duration-200 hover:translate-y-[-1px] hover:shadow-sm\">\r\n  Click me\r\n</button>\r\n\r\n// Expressive - noticeable but not distracting\r\n<div className=\"transition-all duration-300 hover:translate-y-[-4px] hover:shadow-lg hover:scale-[1.02]\">\r\n  Card content\r\n</div>\r\n\r\n// Dramatic - bold, theatrical\r\n<div className=\"transition-all duration-500 ease-[cubic-bezier(0.34,1.56,0.64,1)] hover:translate-y-[-8px] hover:shadow-2xl hover:scale-105 hover:rotate-1\">\r\n  Feature card\r\n</div>\r\n```\r\n\r\n### Card Hover Effect\r\n\r\n```tsx\r\n// Standard card with hover\r\n<div className=\"bg-card rounded-xl p-6 shadow-md\r\n               transition-all duration-300\r\n               hover:shadow-lg hover:scale-[1.02] hover:-translate-y-1\">\r\n  <h3 className=\"font-display text-xl text-foreground\">Title</h3>\r\n  <p className=\"text-muted-foreground\">Description</p>\r\n</div>\r\n```\r\n\r\n### Button Hover Effects\r\n\r\n```tsx\r\n// Primary button with lift effect\r\n<button className=\"px-6 py-3 bg-primary text-white rounded-lg font-semibold\r\n                   shadow-lg transition-all duration-200\r\n                   hover:shadow-xl hover:scale-105\">\r\n  Get Started\r\n</button>\r\n\r\n// Ghost button with background fill\r\n<button className=\"px-6 py-3 border border-primary text-primary rounded-lg\r\n                   transition-all duration-200\r\n                   hover:bg-primary hover:text-white\">\r\n  Learn More\r\n</button>\r\n```\r\n\r\n### Framer Motion Patterns (if installed)\r\n\r\nOnly use if `framer-motion` is in architecture.md PACKAGES:\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { motion } from 'framer-motion'\r\n\r\n// Fade in on mount\r\n<motion.div\r\n  initial={{ opacity: 0, y: 20 }}\r\n  animate={{ opacity: 1, y: 0 }}\r\n  transition={{ duration: 0.5 }}\r\n>\r\n  Content\r\n</motion.div>\r\n\r\n// Staggered children\r\n<motion.div\r\n  initial=\"hidden\"\r\n  animate=\"visible\"\r\n  variants={{\r\n    hidden: { opacity: 0 },\r\n    visible: {\r\n      opacity: 1,\r\n      transition: { staggerChildren: 0.1 }\r\n    }\r\n  }}\r\n>\r\n  {items.map(item => (\r\n    <motion.div\r\n      key={item.id}\r\n      variants={{\r\n        hidden: { opacity: 0, y: 20 },\r\n        visible: { opacity: 1, y: 0 }\r\n      }}\r\n    >\r\n      {item.content}\r\n    </motion.div>\r\n  ))}\r\n</motion.div>\r\n\r\n// Hover animation\r\n<motion.div\r\n  whileHover={{ scale: 1.05, rotate: 1 }}\r\n  transition={{ type: 'spring', stiffness: 300 }}\r\n>\r\n  Interactive element\r\n</motion.div>\r\n```\r\n\r\n### Page Transition Pattern\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { motion } from 'framer-motion'\r\n\r\nexport default function Page() {\r\n  return (\r\n    <motion.div\r\n      initial={{ opacity: 0 }}\r\n      animate={{ opacity: 1 }}\r\n      exit={{ opacity: 0 }}\r\n      transition={{ duration: 0.3 }}\r\n    >\r\n      Page content\r\n    </motion.div>\r\n  )\r\n}\r\n```\r\n\r\n### Loading States\r\n\r\n```tsx\r\n// Spinner animation\r\n<div className=\"animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full\" />\r\n\r\n// Pulse skeleton\r\n<div className=\"animate-pulse bg-muted/20 rounded-lg h-24\" />\r\n\r\n// Bounce indicator\r\n<div className=\"flex gap-1\">\r\n  {[0, 1, 2].map(i => (\r\n    <div\r\n      key={i}\r\n      className=\"w-2 h-2 bg-primary rounded-full animate-bounce\"\r\n      style={{ animationDelay: `${i * 0.1}s` }}\r\n    />\r\n  ))}\r\n</div>\r\n```\r\n\r\n### Focus States (Accessibility)\r\n\r\n```tsx\r\n// Focus ring for keyboard navigation\r\n<button className=\"focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2\r\n                   transition-all duration-200\">\r\n  Accessible Button\r\n</button>\r\n\r\n// Focus within for form groups\r\n<div className=\"focus-within:ring-2 focus-within:ring-primary rounded-lg p-2\">\r\n  <input className=\"outline-none\" />\r\n</div>\r\n```\r\n\r\n### Micro-Interactions\r\n\r\n```tsx\r\n// Icon rotation on hover\r\n<button className=\"group\">\r\n  <ArrowRight className=\"transition-transform duration-200 group-hover:translate-x-1\" />\r\n</button>\r\n\r\n// Link underline animation\r\n<a className=\"relative after:absolute after:bottom-0 after:left-0 after:h-0.5 after:w-0 after:bg-primary\r\n              after:transition-all after:duration-200 hover:after:w-full\">\r\n  Learn More\r\n</a>\r\n\r\n// Color transition\r\n<div className=\"bg-card transition-colors duration-200 hover:bg-primary/10\">\r\n  Hoverable area\r\n</div>\r\n```\r\n\r\n### RULES\r\n\r\n1. Match motion_level from architecture.md DESIGN_DIRECTION\r\n2. Always use `transition-all` with explicit duration\r\n3. Use `ease-out` or custom cubic-bezier for natural feel\r\n4. Don't over-animate - motion should enhance, not distract\r\n5. Ensure focus states are visible for accessibility\r\n6. Only use framer-motion if it's in PACKAGES",
  },
  "app-structure": {
    name: "app-structure",
    description: "Define app folder structure, component organization, and routes for architecture.md output. Use when designing any new app architecture.",
    category: "architecture",
    agents: ["architecture"],
    instructions: "## When to Use\r\n- Starting a new architecture design\r\n- Creating the architecture.md document\r\n- Defining app name, routes, and components\r\n\r\n## Instructions\r\n\r\n### OUTPUT FORMAT (write to architecture.md):\r\n\r\n```\r\nAPP_NAME: kebab-case-name\r\nDESCRIPTION: One sentence\r\n\r\nDESIGN_DIRECTION:\r\n  aesthetic: [choose one: brutally-minimal | maximalist | retro-futuristic | organic-natural | luxury-refined | playful | editorial | brutalist | art-deco | soft-pastel | industrial]\r\n\r\n  color_scheme:\r\n    light:\r\n      primary: \"#hex\"\r\n      accent: \"#hex\"\r\n      background: \"#hex\"\r\n      surface: \"#hex\"\r\n      text: \"#hex\"\r\n      muted: \"#hex\"\r\n    dark:\r\n      primary: \"#hex\"\r\n      accent: \"#hex\"\r\n      background: \"#hex\"\r\n      surface: \"#hex\"\r\n      text: \"#hex\"\r\n      muted: \"#hex\"\r\n\r\n  typography:\r\n    pairing: [editorial | brutalist | playful | luxury | retro | geometric | humanist | minimal | bold | elegant]\r\n    scale: [tight | normal | loose]\r\n\r\n  motion_level: [none | subtle | expressive | dramatic]\r\n  spacing_scale: [tight | normal | loose]\r\n  shadow_system: [flat | subtle | elevated | dramatic]\r\n  radius_system: [sharp | subtle | rounded | pill]\r\n  spatial_style: [symmetric | asymmetric | grid-breaking | overlapping]\r\n  texture: [clean | noise | gradient-mesh | geometric]\r\n  signature_element: \"One unique memorable feature\"\r\n  component_hints: [\"hero-centered\", \"features-grid\", \"pricing-cards\"]\r\n\r\nPACKAGES:\r\n- package-name: why needed\r\n\r\nROUTES:\r\n- / (purpose)\r\n\r\nCOMPONENTS:\r\n- ComponentName: purpose\r\n```\r\n\r\n### DEFAULT STACK (already in E2B template):\r\nNext.js 16 (App Router), Tailwind CSS v4, shadcn/ui, TypeScript, Lucide React\r\n\r\nMost apps need NOTHING more than the default stack.\r\n\r\n### CRITICAL RULES:\r\n1. CORE FUNCTIONALITY ONLY - no extras, no dashboards unless requested\r\n2. NEVER add packages \"just in case\" - each adds ~30s install time\r\n3. Color values MUST be actual hex (not placeholders)\r\n4. ALWAYS include a signature_element\r\n5. NEVER use default white/gray/slate colors\r\n\r\nUse write_file to save architecture.md",
  },
  "auth-setup": {
    name: "auth-setup",
    description: "Configure Supabase authentication with environment variables. Use when adding user authentication to an app.",
    category: "supabase",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Adding user authentication to an app\r\n- Setting up OAuth providers\r\n- Creating auth-protected routes\r\n- Architecture.md mentions authentication\r\n\r\n## Instructions\r\n\r\n### Environment Setup\r\n\r\n**Create .env.local.example (documentation only):**\r\n\r\n```env\r\n# Supabase Configuration\r\n# Get these values from your Supabase project settings\r\nNEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co\r\nNEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\r\n\r\n# OAuth Providers (optional - configure in Supabase Dashboard)\r\n# NEXT_PUBLIC_GOOGLE_CLIENT_ID=your-google-client-id\r\n# NEXT_PUBLIC_GITHUB_CLIENT_ID=your-github-client-id\r\n```\r\n\r\n**⚠️ NEVER create or overwrite `.env.local`** — it's auto-provisioned with real credentials.\r\n\r\n### Supabase Client with Auth\r\n\r\nAuth apps use the SAME two-file client setup as the `database-queries` skill:\r\n\r\n**lib/supabase/client.ts** — for Client Components ('use client'):\r\n```typescript\r\nimport { createBrowserClient } from '@supabase/ssr'\r\n\r\nexport function createClient() {\r\n  return createBrowserClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\r\n  )\r\n}\r\n```\r\n\r\n**lib/supabase/server.ts** — for Server Components, Route Handlers, Server Actions:\r\n```typescript\r\nimport { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies()\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() { return cookieStore.getAll() },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            )\r\n          } catch { /* Server Components can't write cookies — middleware handles it */ }\r\n        },\r\n      },\r\n    }\r\n  )\r\n}\r\n```\r\n\r\n### Auth Hook Pattern\r\n\r\n```tsx\r\n// hooks/useAuth.ts\r\n'use client'\r\n\r\nimport { useState, useEffect } from 'react'\r\nimport { User } from '@supabase/supabase-js'\r\nimport { createClient } from '@/lib/supabase/client'\r\n\r\nexport function useAuth() {\r\n  const [user, setUser] = useState<User | null>(null)\r\n  const [loading, setLoading] = useState(true)\r\n  const supabase = createClient()\r\n\r\n  useEffect(() => {\r\n    // Get initial user — use getUser() NOT getSession()\r\n    supabase.auth.getUser().then(({ data: { user } }) => {\r\n      setUser(user)\r\n      setLoading(false)\r\n    })\r\n\r\n    // Listen for auth changes\r\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\r\n      (_event, session) => {\r\n        setUser(session?.user ?? null)\r\n        setLoading(false)\r\n      }\r\n    )\r\n\r\n    return () => subscription.unsubscribe()\r\n  }, [])\r\n\r\n  return { user, loading }\r\n}\r\n```\r\n\r\n### Sign In/Sign Up Patterns\r\n\r\n**Email + Password:**\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useState } from 'react'\r\nimport { createClient } from '@/lib/supabase/client'\r\n\r\nexport function AuthForm() {\r\n  const [email, setEmail] = useState('')\r\n  const [password, setPassword] = useState('')\r\n  const [loading, setLoading] = useState(false)\r\n  const [error, setError] = useState<string | null>(null)\r\n  const supabase = createClient()\r\n\r\n  async function handleSignUp() {\r\n    setLoading(true)\r\n    setError(null)\r\n\r\n    const { error } = await supabase.auth.signUp({\r\n      email,\r\n      password,\r\n    })\r\n\r\n    if (error) {\r\n      setError(error.message)\r\n    } else {\r\n      setError('Check your email for the confirmation link!')\r\n    }\r\n    setLoading(false)\r\n  }\r\n\r\n  async function handleSignIn() {\r\n    setLoading(true)\r\n    setError(null)\r\n\r\n    const { error } = await supabase.auth.signInWithPassword({\r\n      email,\r\n      password,\r\n    })\r\n\r\n    if (error) {\r\n      setError(error.message)\r\n    }\r\n    setLoading(false)\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-4\">\r\n      <input\r\n        type=\"email\"\r\n        placeholder=\"Email\"\r\n        value={email}\r\n        onChange={(e) => setEmail(e.target.value)}\r\n        className=\"w-full p-2 border rounded\"\r\n      />\r\n      <input\r\n        type=\"password\"\r\n        placeholder=\"Password\"\r\n        value={password}\r\n        onChange={(e) => setPassword(e.target.value)}\r\n        className=\"w-full p-2 border rounded\"\r\n      />\r\n      {error && <p className=\"text-red-500 text-sm\">{error}</p>}\r\n      <div className=\"flex gap-2\">\r\n        <button onClick={handleSignIn} disabled={loading}>\r\n          Sign In\r\n        </button>\r\n        <button onClick={handleSignUp} disabled={loading}>\r\n          Sign Up\r\n        </button>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n**OAuth (Google, GitHub):**\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { createClient } from '@/lib/supabase/client'\r\n\r\nexport function OAuthButtons() {\r\n  const supabase = createClient()\r\n\r\n  async function signInWithGoogle() {\r\n    await supabase.auth.signInWithOAuth({\r\n      provider: 'google',\r\n      options: {\r\n        redirectTo: `${window.location.origin}/auth/callback`,\r\n      },\r\n    })\r\n  }\r\n\r\n  async function signInWithGitHub() {\r\n    await supabase.auth.signInWithOAuth({\r\n      provider: 'github',\r\n      options: {\r\n        redirectTo: `${window.location.origin}/auth/callback`,\r\n      },\r\n    })\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-2\">\r\n      <button onClick={signInWithGoogle} className=\"w-full p-2 border rounded\">\r\n        Continue with Google\r\n      </button>\r\n      <button onClick={signInWithGitHub} className=\"w-full p-2 border rounded\">\r\n        Continue with GitHub\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### OAuth Callback Route\r\n\r\n**app/auth/callback/route.ts** — MUST use server client (cookies required for session):\r\n\r\n```typescript\r\nimport { createClient } from '@/lib/supabase/server'\r\nimport { NextResponse } from 'next/server'\r\n\r\nexport async function GET(request: Request) {\r\n  const { searchParams, origin } = new URL(request.url)\r\n  const code = searchParams.get('code')\r\n  const next = searchParams.get('next') ?? '/'\r\n\r\n  if (code) {\r\n    const supabase = await createClient()\r\n    const { error } = await supabase.auth.exchangeCodeForSession(code)\r\n    if (!error) {\r\n      return NextResponse.redirect(`${origin}${next}`)\r\n    }\r\n  }\r\n  return NextResponse.redirect(`${origin}/auth/auth-code-error`)\r\n}\r\n```\r\n\r\n### Middleware (REQUIRED for Auth Apps)\r\n\r\nCreate `middleware.ts` in the project root. This refreshes expired auth tokens on every request — without it, users get randomly logged out.\r\n\r\n```typescript\r\n// middleware.ts\r\nimport { createServerClient } from '@supabase/ssr'\r\nimport { NextResponse, type NextRequest } from 'next/server'\r\n\r\nexport async function middleware(request: NextRequest) {\r\n  let supabaseResponse = NextResponse.next({ request })\r\n\r\n  const supabase = createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() { return request.cookies.getAll() },\r\n        setAll(cookiesToSet) {\r\n          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))\r\n          supabaseResponse = NextResponse.next({ request })\r\n          cookiesToSet.forEach(({ name, value, options }) =>\r\n            supabaseResponse.cookies.set(name, value, options)\r\n          )\r\n        },\r\n      },\r\n    }\r\n  )\r\n\r\n  // CRITICAL: Do NOT run any code between createServerClient and getUser()\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n\r\n  // Redirect unauthenticated users from protected routes\r\n  if (!user && !request.nextUrl.pathname.startsWith('/login') && !request.nextUrl.pathname.startsWith('/auth') && request.nextUrl.pathname !== '/') {\r\n    const url = request.nextUrl.clone()\r\n    url.pathname = '/login'\r\n    return NextResponse.redirect(url)\r\n  }\r\n\r\n  return supabaseResponse\r\n}\r\n\r\nexport const config = {\r\n  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],\r\n}\r\n```\r\n\r\n### User Profiles Table (REQUIRED)\r\n\r\nThe `auth.users` table is NOT accessible via PostgREST. Create a `profiles` table in schema.sql for any user data you need in queries:\r\n\r\n```sql\r\nCREATE TABLE IF NOT EXISTS profiles (\r\n  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\r\n  created_at timestamptz DEFAULT now(),\r\n  display_name text,\r\n  avatar_url text,\r\n  email text\r\n);\r\n\r\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Anyone can view profiles\r\nDO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'profiles' AND policyname = 'Public profiles') THEN\r\n  CREATE POLICY \"Public profiles\" ON profiles FOR SELECT USING (true);\r\nEND IF; END $$;\r\n\r\n-- Users can update their own profile\r\nDO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'profiles' AND policyname = 'Users update own profile') THEN\r\n  CREATE POLICY \"Users update own profile\" ON profiles FOR UPDATE TO authenticated USING ((select auth.uid()) = id);\r\nEND IF; END $$;\r\n\r\n-- Users can insert their own profile\r\nDO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'profiles' AND policyname = 'Users insert own profile') THEN\r\n  CREATE POLICY \"Users insert own profile\" ON profiles FOR INSERT TO authenticated WITH CHECK ((select auth.uid()) = id);\r\nEND IF; END $$;\r\n```\r\n\r\nUse this table for all joins where you need user info (display name, avatar, etc.) instead of trying to join `auth.users`.\r\n\r\n### Sign Out\r\n\r\n```tsx\r\nimport { createClient } from '@/lib/supabase/client'\r\n\r\nasync function signOut() {\r\n  const supabase = createClient()\r\n  await supabase.auth.signOut()\r\n  // User state will update via onAuthStateChange listener\r\n}\r\n```\r\n\r\n### Protected Route Pattern\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useEffect } from 'react'\r\nimport { useRouter } from 'next/navigation'\r\nimport { useAuth } from '@/hooks/useAuth'\r\n\r\nexport function ProtectedPage({ children }: { children: React.ReactNode }) {\r\n  const { user, loading } = useAuth()\r\n  const router = useRouter()\r\n\r\n  useEffect(() => {\r\n    if (!loading && !user) {\r\n      router.push('/login')\r\n    }\r\n  }, [user, loading, router])\r\n\r\n  if (loading) {\r\n    return <div>Loading...</div>\r\n  }\r\n\r\n  if (!user) {\r\n    return null\r\n  }\r\n\r\n  return <>{children}</>\r\n}\r\n```\r\n\r\n### User Profile Component\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useAuth } from '@/hooks/useAuth'\r\nimport { createClient } from '@/lib/supabase/client'\r\n\r\nexport function UserProfile() {\r\n  const { user, loading } = useAuth()\r\n  const supabase = createClient()\r\n\r\n  if (loading) return <div>Loading...</div>\r\n\r\n  if (!user) {\r\n    return <a href=\"/login\">Sign In</a>\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex items-center gap-4\">\r\n      <span>{user.email}</span>\r\n      <button onClick={() => supabase.auth.signOut()}>\r\n        Sign Out\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### RULES\r\n\r\n1. **NEVER create .env.local** — it's auto-provisioned\r\n2. **Always create .env.local.example** — for documentation\r\n3. **Use onAuthStateChange listener** — for reactive auth state\r\n4. **Handle loading state** — don't flash content during auth check\r\n5. **Redirect after OAuth** — use redirectTo option\r\n6. **Store user data in separate table** — don't rely only on auth.users\r\n7. **ALWAYS use getUser(), NEVER getSession()** — getSession() doesn't revalidate the auth token on the server\r\n8. **Create middleware.ts** for every auth app — refreshes tokens, protects routes\r\n9. **Create profiles table** in schema.sql — auth.users is NOT queryable via PostgREST\r\n10. **NEVER put code between createServerClient and getUser()** in middleware — causes random logouts\r\n11. **Cookie methods: ONLY use getAll/setAll** — never use individual get/set/remove",
  },
  "client-server": {
    name: "client-server",
    description: "Decide between 'use client' and server components. CRITICAL - async + 'use client' = CRASH. Use when choosing component type or using dynamic imports.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Deciding if a component needs 'use client'\r\n- Creating async data-fetching components\r\n- Using dynamic imports with { ssr: false }\r\n- Fixing \"async client component\" crashes\r\n\r\n## Instructions\r\n\r\n### ⚠️ CRITICAL RULE: async + 'use client' = CRASH\r\n\r\n```tsx\r\n// ❌ CRASHES! Client Components CANNOT be async\r\n'use client'\r\nexport default async function Page() {\r\n  const data = await fetchData() // This crashes the app!\r\n  return <div>{data}</div>\r\n}\r\n```\r\n\r\n### Component Type Decision Table\r\n\r\n| Component Has | Needs 'use client' | Can Be async |\r\n|---------------|-------------------|--------------|\r\n| useState, useEffect, useRef | YES | NO |\r\n| onClick, onChange, onSubmit | YES | NO |\r\n| Browser APIs (window, localStorage) | YES | NO |\r\n| Only props + JSX (no hooks) | NO | YES |\r\n| await/fetch calls | NO | YES |\r\n| useContext with client state | YES | NO |\r\n\r\n### Server Component (Default - No Directive)\r\n\r\nServer components are the default. They can be async and fetch data directly:\r\n\r\n```tsx\r\n// app/products/page.tsx\r\n// No 'use client' = Server Component (default)\r\n\r\nasync function getProducts() {\r\n  const res = await fetch('https://api.example.com/products')\r\n  return res.json()\r\n}\r\n\r\nexport default async function ProductsPage() {\r\n  const products = await getProducts()\r\n\r\n  return (\r\n    <div className=\"grid grid-cols-3 gap-6\">\r\n      {products.map((product) => (\r\n        <div key={product.id} className=\"p-4 bg-card rounded-lg\">\r\n          <h2>{product.name}</h2>\r\n          <p>${product.price}</p>\r\n        </div>\r\n      ))}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### Client Component (With Interactivity)\r\n\r\nAdd 'use client' for any interactive functionality:\r\n\r\n```tsx\r\n// components/Counter.tsx\r\n'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\nexport function Counter() {\r\n  const [count, setCount] = useState(0)\r\n\r\n  return (\r\n    <button onClick={() => setCount(count + 1)}>\r\n      Count: {count}\r\n    </button>\r\n  )\r\n}\r\n```\r\n\r\n### Client Component with Data Fetching\r\n\r\nClient components fetch data with useEffect:\r\n\r\n```tsx\r\n// components/UserProfile.tsx\r\n'use client'\r\n\r\nimport { useState, useEffect } from 'react'\r\n\r\ninterface User {\r\n  id: string\r\n  name: string\r\n  email: string\r\n}\r\n\r\nexport function UserProfile({ userId }: { userId: string }) {\r\n  const [user, setUser] = useState<User | null>(null)\r\n  const [loading, setLoading] = useState(true)\r\n\r\n  useEffect(() => {\r\n    async function fetchUser() {\r\n      const res = await fetch(`/api/users/${userId}`)\r\n      const data = await res.json()\r\n      setUser(data)\r\n      setLoading(false)\r\n    }\r\n    fetchUser()\r\n  }, [userId])\r\n\r\n  if (loading) return <div>Loading...</div>\r\n  if (!user) return <div>User not found</div>\r\n\r\n  return (\r\n    <div>\r\n      <h1>{user.name}</h1>\r\n      <p>{user.email}</p>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### Dynamic Import with { ssr: false }\r\n\r\nFor client-only packages that access browser APIs:\r\n\r\n```tsx\r\n// app/game/page.tsx\r\n'use client'\r\n\r\nimport dynamic from 'next/dynamic'\r\n\r\n// These packages access browser APIs and cannot run on server:\r\n// phaser, pixi.js, three, @react-three/fiber, gsap, react-leaflet\r\n\r\nconst Game = dynamic(() => import('@/components/Game'), {\r\n  ssr: false,\r\n  loading: () => <div>Loading game...</div>\r\n})\r\n\r\nexport default function GamePage() {\r\n  return (\r\n    <div className=\"min-h-screen\">\r\n      <h1>Game</h1>\r\n      <Game />\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### Dynamic Routes (await params)\r\n\r\nNext.js 15+ requires awaiting params in async components:\r\n\r\n```tsx\r\n// app/posts/[id]/page.tsx\r\n// Server Component - can be async\r\n\r\ninterface Props {\r\n  params: Promise<{ id: string }>\r\n}\r\n\r\nexport default async function PostPage({ params }: Props) {\r\n  const { id } = await params\r\n  const post = await getPost(id)\r\n\r\n  return (\r\n    <article>\r\n      <h1>{post.title}</h1>\r\n      <p>{post.content}</p>\r\n    </article>\r\n  )\r\n}\r\n```\r\n\r\n### Mixing Server and Client Components\r\n\r\nServer components can import and render client components:\r\n\r\n```tsx\r\n// app/dashboard/page.tsx (Server Component)\r\nimport { DashboardStats } from '@/components/DashboardStats' // Client Component\r\n\r\nasync function getStats() {\r\n  const res = await fetch('/api/stats')\r\n  return res.json()\r\n}\r\n\r\nexport default async function DashboardPage() {\r\n  const initialStats = await getStats()\r\n\r\n  return (\r\n    <div>\r\n      <h1>Dashboard</h1>\r\n      {/* Pass server-fetched data to client component */}\r\n      <DashboardStats initialStats={initialStats} />\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n```tsx\r\n// components/DashboardStats.tsx (Client Component)\r\n'use client'\r\n\r\nimport { useState, useEffect } from 'react'\r\n\r\ninterface Stats {\r\n  users: number\r\n  revenue: number\r\n}\r\n\r\nexport function DashboardStats({ initialStats }: { initialStats: Stats }) {\r\n  const [stats, setStats] = useState(initialStats)\r\n\r\n  useEffect(() => {\r\n    // Optional: Poll for updates\r\n    const interval = setInterval(async () => {\r\n      const res = await fetch('/api/stats')\r\n      const newStats = await res.json()\r\n      setStats(newStats)\r\n    }, 30000)\r\n\r\n    return () => clearInterval(interval)\r\n  }, [])\r\n\r\n  return (\r\n    <div className=\"grid grid-cols-2 gap-4\">\r\n      <div className=\"p-4 bg-card rounded-lg\">\r\n        <p className=\"text-muted-foreground\">Users</p>\r\n        <p className=\"text-2xl font-bold\">{stats.users}</p>\r\n      </div>\r\n      <div className=\"p-4 bg-card rounded-lg\">\r\n        <p className=\"text-muted-foreground\">Revenue</p>\r\n        <p className=\"text-2xl font-bold\">${stats.revenue}</p>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### SSR-Safe vs Client-Only Packages\r\n\r\n**SSR-Safe (import normally):**\r\n- recharts, @tremor/react, framer-motion\r\n- react-hook-form, zod, zustand\r\n- @tanstack/react-query, date-fns\r\n- react-markdown, @supabase/supabase-js\r\n\r\n**Client-Only (need dynamic import with ssr: false):**\r\n- phaser, pixi.js, three, @react-three/fiber\r\n- gsap, react-leaflet\r\n\r\n### RULES\r\n\r\n1. **'use client' + async = CRASH** — never combine them\r\n2. **Server Components are default** — no directive needed\r\n3. **Add 'use client' for interactivity** — hooks, event handlers\r\n4. **Use dynamic import for browser-only packages** — with ssr: false\r\n5. **Server fetches data, client renders interactivity** — pass data as props\r\n6. **await params in dynamic routes** — Next.js 15+ requirement",
  },
  "data-modeling": {
    name: "data-modeling",
    description: "Design database schema, tables, columns, and types for apps needing data persistence. Use when the app requires saving or retrieving data.",
    category: "architecture",
    agents: ["architecture"],
    instructions: "## When to Use\r\n- App needs to save user data\r\n- App needs to persist state across sessions\r\n- User explicitly requests database/storage/persistence\r\n- Features like: user accounts, saving items, tracking progress\r\n\r\n## Instructions\r\n\r\n### DATABASE SECTION FORMAT\r\n\r\nAdd to architecture.md only if app needs persistence:\r\n\r\n```\r\nDATABASE:\r\n  tables:\r\n    - table_name:\r\n      - id: uuid (pk, default gen_random_uuid())\r\n      - created_at: timestamptz (default now())\r\n      - column_name: type (constraint)\r\n  env_vars:\r\n    - NEXT_PUBLIC_SUPABASE_URL\r\n    - NEXT_PUBLIC_SUPABASE_ANON_KEY\r\n```\r\n\r\n**IMPORTANT**: When this DATABASE section exists, the coder agent MUST produce a `schema.sql` file from this specification. The column names defined here will become both SQL column names and TypeScript interface field names.\r\n\r\n### COLUMN TYPES (Supabase/PostgreSQL)\r\n| Type | Use For |\r\n|------|---------|\r\n| uuid | Primary keys, foreign keys |\r\n| text | Strings of any length |\r\n| boolean | true/false flags |\r\n| integer | Whole numbers |\r\n| timestamptz | Dates and times |\r\n| jsonb | Flexible nested data |\r\n\r\n### DATABASE RULES\r\n1. Every table MUST have:\r\n   - `id: uuid (pk, default gen_random_uuid())`\r\n   - `created_at: timestamptz (default now())`\r\n\r\n2. Naming conventions:\r\n   - Tables: snake_case plural (e.g., `users`, `todo_items`)\r\n   - Columns: snake_case (e.g., `user_id`, `is_completed`)\r\n\r\n3. Scale appropriately:\r\n   - Simple apps (todo, blog): 1-3 tables\r\n   - Medium apps (dashboard, CMS): 3-6 tables\r\n   - Complex apps (project management, SaaS): 6-12 tables with relationships\r\n   - ALWAYS define foreign key relationships explicitly (see below)\r\n\r\n4. PACKAGES required:\r\n   - ALWAYS add both `@supabase/supabase-js` AND `@supabase/ssr` to PACKAGES section\r\n   - If auth is needed: also add a note that middleware.ts is required\r\n\r\n5. schema.sql is MANDATORY:\r\n   - The coder agent MUST create `schema.sql` from this DATABASE specification\r\n   - Without schema.sql, the auto-execution pipeline has nothing to execute\r\n\r\n6. If auth is needed: ALWAYS include a `profiles` table with `id: uuid (pk, fk -> auth.users.id)`, `display_name: text`, `avatar_url: text`, `email: text`. Use `profiles.id` (not `auth.users.id`) for all foreign key references that need to be queried via PostgREST.\r\n\r\n7. SECURITY DEFINER requirement:\r\n   - If schema has **3+ tables with foreign key relationships**, the coder/schema agent MUST create a `SECURITY DEFINER` helper function in schema.sql\r\n   - Note this in a comment: `-- NOTE: 3+ tables with FKs = SECURITY DEFINER helper required`\r\n   - This prevents infinite recursion in RLS policies when policies query across tables\r\n\r\n8. Table ordering (FK dependency):\r\n   - List tables in parent-before-child order in the DATABASE section\r\n   - Root tables (no FK dependencies) first\r\n   - Child tables that reference parent tables after their parents\r\n   - Example: `workspaces` → `workspace_members` → `projects` → `issues` → `comments`\r\n   - This ordering is critical for schema.sql generation — CREATE TABLE must follow this order\r\n\r\n### Relationships (Foreign Keys)\r\n\r\nWhen tables reference each other, specify foreign keys explicitly:\r\n\r\n```\r\nDATABASE:\r\n  tables:\r\n    - workspaces:\r\n      - id: uuid (pk, default gen_random_uuid())\r\n      - created_at: timestamptz (default now())\r\n      - name: text (not null)\r\n      - owner_id: uuid (fk -> auth.users.id, not null)\r\n\r\n    - projects:\r\n      - id: uuid (pk, default gen_random_uuid())\r\n      - created_at: timestamptz (default now())\r\n      - workspace_id: uuid (fk -> workspaces.id, on delete cascade, not null)\r\n      - name: text (not null)\r\n      - status: text (default 'active')\r\n\r\n    - issues:\r\n      - id: uuid (pk, default gen_random_uuid())\r\n      - created_at: timestamptz (default now())\r\n      - project_id: uuid (fk -> projects.id, on delete cascade, not null)\r\n      - assignee_id: uuid (fk -> profiles.id, nullable)\r\n      - title: text (not null)\r\n      - priority: text (default 'medium')\r\n```\r\n\r\n**FK syntax**: `column_name: uuid (fk -> table.column, on delete cascade|set null, not null|nullable)`\r\n\r\n**Rules for FKs**:\r\n- User references: ALWAYS use `fk -> profiles.id` (NOT `auth.users.id`) for columns that need to be queryable via PostgREST\r\n- Owner/creator references: Use `fk -> auth.users.id` only for the ownership column that RLS policies check against `auth.uid()`\r\n- Cascade: Use `on delete cascade` for child tables (deleting parent deletes children)\r\n- Set null: Use `on delete set null` for optional references (e.g., assignee_id when user is deleted)\r\n\r\n### Status/Enum Columns\r\n\r\nFor columns with a fixed set of values, use `text` with a comment listing valid values:\r\n\r\n```\r\n- status: text (default 'active') -- values: active, archived, deleted\r\n- priority: text (default 'medium') -- values: low, medium, high, urgent\r\n- role: text (default 'member') -- values: owner, admin, member, viewer\r\n```\r\n\r\nThe coder agent will enforce these values in the TypeScript type definition:\r\n```typescript\r\ntype Priority = 'low' | 'medium' | 'high' | 'urgent'\r\n```\r\n\r\n### Column Naming Guidance\r\n\r\nColumn names in the DATABASE section become:\r\n1. SQL column names in `schema.sql` (e.g., `text text NOT NULL`)\r\n2. TypeScript interface fields (e.g., `text: string`)\r\n3. Supabase query parameters (e.g., `.insert({ text: '...' })`)\r\n\r\nChoose names that work as both SQL columns AND TypeScript fields. Prefer: `title`, `content`, `description`, `name`, `status`, `completed`.\r\n\r\nAvoid generic names like `data`, `value`, `item` that may conflict with JS keywords.\r\n\r\n### WHEN NOT TO ADD DATABASE\r\n- Simple calculators, converters\r\n- Static content display\r\n- Games that don't save progress\r\n- Timers, clocks, stopwatches\r\n- Single-session tools",
  },
  "database-queries": {
    name: "database-queries",
    description: "Implement Supabase database CRUD operations. Use when architecture.md has DATABASE section. Includes client setup and data fetching patterns.",
    category: "supabase",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Architecture.md has a DATABASE section\r\n- Creating, reading, updating, or deleting data\r\n- Setting up Supabase client\r\n- Fetching data in components\r\n\r\n## Instructions\r\n\r\n### Prerequisites\r\n\r\nOnly use Supabase when architecture.md has a DATABASE section.\r\n\r\n### CRITICAL — schema.sql Generation\r\n\r\n⚠️ **MANDATORY**: When architecture.md has a DATABASE section, you MUST create `schema.sql` in the project root BEFORE any component files.\r\n\r\n- **schema.sql is the PRIMARY deliverable** — without it, the auto-execution pipeline has nothing to execute and the database will be empty. All CRUD operations will fail silently.\r\n- **Create schema.sql BEFORE `lib/supabase/client.ts`** — the schema defines what the client will query.\r\n- **Every table in the DATABASE section** MUST have a corresponding `CREATE TABLE IF NOT EXISTS` statement in schema.sql.\r\n\r\n### File Setup\r\n\r\n⚠️ **CRITICAL: NEVER hardcode Supabase URL or anon key.** The URL and key MUST come from environment variables. NEVER use string literals like `'https://xxx.supabase.co'` or paste actual keys.\r\n\r\n**1. lib/supabase/client.ts — for Client Components ('use client'):**\r\n\r\n```typescript\r\nimport { createBrowserClient } from '@supabase/ssr'\r\n\r\nexport function createClient() {\r\n  return createBrowserClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\r\n  )\r\n}\r\n```\r\n\r\n**2. lib/supabase/server.ts — for Server Components, Route Handlers, Server Actions:**\r\n\r\n```typescript\r\nimport { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies()\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() { return cookieStore.getAll() },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            )\r\n          } catch { /* Server Components can't write cookies — middleware handles it */ }\r\n        },\r\n      },\r\n    }\r\n  )\r\n}\r\n```\r\n\r\n**Usage in components:**\r\n```typescript\r\n// In 'use client' components:\r\nimport { createClient } from '@/lib/supabase/client'\r\nconst supabase = createClient()\r\n\r\n// In server components, route handlers, server actions:\r\nimport { createClient } from '@/lib/supabase/server'\r\nconst supabase = await createClient()\r\n```\r\n\r\n**3. .env.local.example - Template (documentation only):**\r\n\r\n```env\r\nNEXT_PUBLIC_SUPABASE_URL=your_supabase_url\r\nNEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key\r\n```\r\n\r\n**⚠️ DO NOT create or overwrite `.env.local`** — it's auto-provisioned with real credentials.\r\n\r\n### CRUD Patterns\r\n\r\n**SELECT (Read):**\r\n\r\n```typescript\r\n// Get all rows\r\nconst { data, error } = await supabase\r\n  .from('todos')\r\n  .select('*')\r\n  .order('created_at', { ascending: false })\r\n\r\n// Get single row\r\nconst { data, error } = await supabase\r\n  .from('todos')\r\n  .select('*')\r\n  .eq('id', todoId)\r\n  .single()\r\n\r\n// Select specific columns\r\nconst { data, error } = await supabase\r\n  .from('todos')\r\n  .select('id, title, completed')\r\n\r\n// Filter with conditions\r\nconst { data, error } = await supabase\r\n  .from('todos')\r\n  .select('*')\r\n  .eq('completed', false)\r\n  .order('created_at', { ascending: false })\r\n  .limit(10)\r\n```\r\n\r\n**INSERT (Create):**\r\n\r\n```typescript\r\n// Insert single row\r\nconst { data, error } = await supabase\r\n  .from('todos')\r\n  .insert({ text: 'New todo', completed: false })\r\n  .select()\r\n\r\n// Insert multiple rows\r\nconst { data, error } = await supabase\r\n  .from('todos')\r\n  .insert([\r\n    { text: 'Todo 1', completed: false },\r\n    { text: 'Todo 2', completed: false },\r\n  ])\r\n  .select()\r\n```\r\n\r\n**UPDATE:**\r\n\r\n```typescript\r\n// Update single row\r\nconst { data, error } = await supabase\r\n  .from('todos')\r\n  .update({ completed: true })\r\n  .eq('id', todoId)\r\n  .select()\r\n\r\n// Update multiple rows\r\nconst { data, error } = await supabase\r\n  .from('todos')\r\n  .update({ completed: true })\r\n  .in('id', ['id1', 'id2', 'id3'])\r\n  .select()\r\n```\r\n\r\n**DELETE:**\r\n\r\n```typescript\r\n// Delete single row\r\nconst { error } = await supabase\r\n  .from('todos')\r\n  .delete()\r\n  .eq('id', todoId)\r\n\r\n// Delete multiple rows\r\nconst { error } = await supabase\r\n  .from('todos')\r\n  .delete()\r\n  .in('id', ['id1', 'id2', 'id3'])\r\n```\r\n\r\n> DELETE operations require a matching DELETE RLS policy on the table. If delete fails silently, check that a DELETE policy exists in schema.sql.\r\n\r\n### Relationship Queries (Foreign Key JOINs)\r\n\r\nWhen schema.sql has foreign keys, use PostgREST embedded select syntax to fetch related data in a single query:\r\n\r\n```typescript\r\n// ❌ NEVER JOIN auth.users — the auth schema is NOT accessible via PostgREST REST API\r\n// assignee:assignee_id (id, email)  ← THIS WILL ALWAYS RETURN NULL\r\n// reporter:reporter_id (id, email, raw_user_meta_data)  ← THIS WILL ALSO RETURN NULL\r\n\r\n// ✅ Instead, create a `profiles` table in public schema (see auth-setup skill)\r\n// Then join profiles:\r\n\r\n// Fetch projects WITH their workspace data\r\n// FK: projects.workspace_id -> workspaces.id\r\nconst { data, error } = await supabase\r\n  .from('projects')\r\n  .select(`\r\n    *,\r\n    workspace:workspace_id (id, name, slug)\r\n  `)\r\n\r\n// Fetch issues WITH assignee (from profiles table) and project info\r\n// FK: issues.assignee_id -> profiles.id, issues.project_id -> projects.id\r\nconst { data, error } = await supabase\r\n  .from('issues')\r\n  .select(`\r\n    *,\r\n    assignee:assignee_id (id, display_name, avatar_url),\r\n    project:project_id (id, name)\r\n  `)\r\n  .eq('project_id', projectId)\r\n  .order('created_at', { ascending: false })\r\n\r\n// Fetch single item with all relationships\r\nconst { data, error } = await supabase\r\n  .from('issues')\r\n  .select(`\r\n    *,\r\n    assignee:assignee_id (id, display_name, avatar_url),\r\n    reporter:reporter_id (id, display_name, avatar_url),\r\n    project:project_id (id, name)\r\n  `)\r\n  .eq('id', issueId)\r\n  .single()\r\n```\r\n\r\n**Syntax: `alias:fk_column (columns)`**\r\n- `alias` — the field name in the returned object (e.g., `workspace`)\r\n- `fk_column` — the foreign key column on the current table (e.g., `workspace_id`)\r\n- `(columns)` — which columns to select from the related table\r\n\r\n**TypeScript interfaces for relationship data:**\r\n\r\n```typescript\r\n// In types/index.ts — add optional fields for embedded relations\r\ninterface Profile {\r\n  id: string\r\n  display_name: string | null\r\n  avatar_url: string | null\r\n  email: string | null\r\n}\r\n\r\ninterface Project {\r\n  id: string\r\n  created_at: string\r\n  workspace_id: string         // FK column (always present)\r\n  name: string\r\n  // ... other direct columns\r\n  workspace?: Workspace        // Embedded data (present when selected with select())\r\n}\r\n\r\ninterface Issue {\r\n  id: string\r\n  created_at: string\r\n  project_id: string\r\n  assignee_id: string | null\r\n  // ... other direct columns\r\n  project?: Project            // Embedded relation\r\n  assignee?: Profile           // From profiles table (NOT auth.users)\r\n}\r\n```\r\n\r\n> **Rule**: Use embedded selects instead of separate queries. One `.select('*, relation:fk(cols)')` is faster and simpler than two sequential fetches.\r\n\r\n### Data Fetching in Components\r\n\r\nUse 'use client' + useState + useEffect for fetching:\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useState, useEffect } from 'react'\r\nimport { createClient } from '@/lib/supabase/client'\r\n\r\ninterface Todo {\r\n  id: string\r\n  text: string\r\n  completed: boolean\r\n  created_at: string\r\n}\r\n\r\nexport function TodoList() {\r\n  const [todos, setTodos] = useState<Todo[]>([])\r\n  const [loading, setLoading] = useState(true)\r\n  const [error, setError] = useState<string | null>(null)\r\n  const supabase = createClient()\r\n\r\n  useEffect(() => {\r\n    fetchTodos()\r\n  }, [])\r\n\r\n  async function fetchTodos() {\r\n    setLoading(true)\r\n    const { data, error } = await supabase\r\n      .from('todos')\r\n      .select('*')\r\n      .order('created_at', { ascending: false })\r\n\r\n    if (error) {\r\n      setError(error.message)\r\n    } else {\r\n      setTodos(data || [])\r\n    }\r\n    setLoading(false)\r\n  }\r\n\r\n  async function addTodo(text: string) {\r\n    const { data, error } = await supabase\r\n      .from('todos')\r\n      .insert({ text, completed: false })\r\n      .select()\r\n\r\n    if (!error && data) {\r\n      setTodos([data[0], ...todos])\r\n    }\r\n  }\r\n\r\n  async function toggleTodo(id: string, completed: boolean) {\r\n    const { error } = await supabase\r\n      .from('todos')\r\n      .update({ completed: !completed })\r\n      .eq('id', id)\r\n\r\n    if (!error) {\r\n      setTodos(todos.map(t => t.id === id ? { ...t, completed: !completed } : t))\r\n    }\r\n  }\r\n\r\n  async function deleteTodo(id: string) {\r\n    const { error } = await supabase\r\n      .from('todos')\r\n      .delete()\r\n      .eq('id', id)\r\n\r\n    if (!error) {\r\n      setTodos(todos.filter(t => t.id !== id))\r\n    }\r\n  }\r\n\r\n  if (loading) return <div>Loading...</div>\r\n  if (error) return <div>Error: {error}</div>\r\n\r\n  return (\r\n    <ul>\r\n      {todos.map(todo => (\r\n        <li key={todo.id} className=\"flex items-center gap-2\">\r\n          <input\r\n            type=\"checkbox\"\r\n            checked={todo.completed}\r\n            onChange={() => toggleTodo(todo.id, todo.completed)}\r\n          />\r\n          <span className={todo.completed ? 'line-through' : ''}>\r\n            {todo.text}\r\n          </span>\r\n          <button onClick={() => deleteTodo(todo.id)}>Delete</button>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n```\r\n\r\n### Error Handling Pattern\r\n\r\n```typescript\r\nasync function safeFetch(tableName: string) {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from(tableName)\r\n      .select('*')\r\n\r\n    if (error) {\r\n      console.error(`Error fetching from ${tableName}:`, error.message)\r\n      return { data: null, error: error.message }\r\n    }\r\n\r\n    return { data, error: null }\r\n  } catch (err) {\r\n    console.error(`Unexpected error fetching from ${tableName}:`, err)\r\n    return { data: null, error: 'An unexpected error occurred' }\r\n  }\r\n}\r\n\r\n// User-facing error state pattern:\r\n// const [error, setError] = useState<string | null>(null)\r\n// if (error) return <div className=\"text-red-500\">Error: {error}</div>\r\n```\r\n\r\n### Database Readiness Pattern\r\n\r\nschema.sql is auto-executed after code generation. During the brief window before execution completes, queries will fail with either:\r\n- **`42P01`** — PostgreSQL: \"relation does not exist\" (table hasn't been created yet)\r\n- **PostgREST schema cache miss** — \"Could not find the table in the schema cache\" (table exists but PostgREST hasn't refreshed)\r\n\r\nUse this pattern to handle BOTH error types gracefully:\r\n\r\n```tsx\r\nconst [data, setData] = useState<Item[]>([])\r\nconst [loading, setLoading] = useState(true)\r\nconst [error, setError] = useState<string | null>(null)\r\nconst [dbReady, setDbReady] = useState(true)\r\n\r\nasync function fetchData() {\r\n  setLoading(true)\r\n  const { data, error } = await supabase\r\n    .from('items')\r\n    .select('*')\r\n    .order('created_at', { ascending: false })\r\n\r\n  if (error) {\r\n    // Two possible \"table not ready\" errors:\r\n    // 1. 42P01 = PostgreSQL hasn't created the table yet\r\n    // 2. \"schema cache\" = PostgREST hasn't picked up new tables yet\r\n    if (error.code === '42P01' || error.message?.includes('schema cache')) {\r\n      setDbReady(false)\r\n      setTimeout(() => {\r\n        setDbReady(true)\r\n        fetchData()\r\n      }, 3000)\r\n      return\r\n    }\r\n    setError(error.message)\r\n  } else {\r\n    setData(data || [])\r\n    setDbReady(true)\r\n  }\r\n  setLoading(false)\r\n}\r\n\r\nuseEffect(() => { fetchData() }, [])\r\n\r\nif (!dbReady) return <div className=\"text-center p-8 text-muted-foreground\">Setting up database...</div>\r\nif (loading) return <div>Loading...</div>\r\nif (error) return <div className=\"text-red-500\">Error: {error}</div>\r\n```\r\n\r\nUse this pattern in the PRIMARY data-fetching component (the one that loads on page mount). Secondary components that only write data (forms, buttons) don't need it — they'll work once the primary component confirms DB readiness.\r\n\r\n> **Tip**: schema.sql should end with `NOTIFY pgrst, 'reload schema';` to force PostgREST to detect new tables immediately. Without this, the API may return \"table not found\" for up to 2 minutes.\r\n\r\n### Common Supabase Errors\r\n\r\n**Table not found — two different errors:**\r\n\r\nBoth mean the table isn't queryable yet. Use the Database Readiness Pattern above to retry automatically.\r\n\r\n```typescript\r\n// Error 1: PostgreSQL — table hasn't been created yet\r\n// {message: 'relation \"public.posts\" does not exist', code: '42P01'}\r\n\r\n// Error 2: PostgREST — table exists but schema cache hasn't refreshed\r\n// {message: 'Could not find the table \\'public.posts\\' in the schema cache', code: ''}\r\n\r\n// BOTH are caught by:\r\nif (error.code === '42P01' || error.message?.includes('schema cache')) {\r\n  // Retry after 3 seconds\r\n}\r\n// If the error persists after 30 seconds, run schema.sql manually in the Supabase SQL Editor.\r\n```\r\n\r\n**RLS blocks access (new row violates policy):**\r\nThis means your INSERT/UPDATE doesn't satisfy the WITH CHECK clause. Common cause: the user_id column doesn't match the authenticated user.\r\n\r\n```typescript\r\n// Error: {message: 'new row violates row-level security policy', code: '42501'}\r\n// FIX: Ensure user_id is set to auth.uid() value, or check RLS policies\r\n```\r\n\r\n**No rows returned (RLS filters everything):**\r\nNot an error — just empty results. This happens when SELECT policy filters out all rows (e.g., no published posts yet, or user has no data).\r\n\r\n```typescript\r\n// data will be [] — this is normal when no rows match the RLS policy\r\n// Show an empty state UI, not an error\r\n```\r\n\r\n### Real-time Subscriptions (if needed)\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useEffect, useState } from 'react'\r\nimport { createClient } from '@/lib/supabase/client'\r\n\r\nexport function RealtimeTodos() {\r\n  const [todos, setTodos] = useState<Todo[]>([])\r\n  const supabase = createClient()\r\n\r\n  useEffect(() => {\r\n    // Initial fetch\r\n    fetchTodos()\r\n\r\n    // Subscribe to changes\r\n    const channel = supabase\r\n      .channel('todos-changes')\r\n      .on(\r\n        'postgres_changes',\r\n        { event: '*', schema: 'public', table: 'todos' },\r\n        (payload) => {\r\n          if (payload.eventType === 'INSERT') {\r\n            setTodos(prev => [payload.new as Todo, ...prev])\r\n          } else if (payload.eventType === 'DELETE') {\r\n            setTodos(prev => prev.filter(t => t.id !== payload.old.id))\r\n          } else if (payload.eventType === 'UPDATE') {\r\n            setTodos(prev =>\r\n              prev.map(t => t.id === payload.new.id ? payload.new as Todo : t)\r\n            )\r\n          }\r\n        }\r\n      )\r\n      .subscribe()\r\n\r\n    return () => {\r\n      supabase.removeChannel(channel)\r\n    }\r\n  }, [])\r\n\r\n  // ... rest of component\r\n}\r\n```\r\n\r\n### Index Recommendations\r\n\r\nAlways create indexes on:\r\n- **Foreign key columns**: Every `_id` column that references another table (e.g., `workspace_id`, `project_id`, `user_id`)\r\n- **Columns used in `.eq()` filters**: If you frequently filter by a column (e.g., `status`, `published`), index it\r\n- **Columns used in `.order()` sorts**: Especially `created_at` for chronological listing\r\n- **Columns referenced in RLS policies**: See the `rls-policies` skill for details\r\n\r\n```sql\r\n-- Add to schema.sql after all policies\r\ncreate index if not exists idx_todos_user_id on todos(user_id);\r\ncreate index if not exists idx_todos_created_at on todos(created_at desc);\r\ncreate index if not exists idx_projects_workspace_id on projects(workspace_id);\r\ncreate index if not exists idx_issues_project_id on issues(project_id);\r\ncreate index if not exists idx_issues_assignee_id on issues(assignee_id);\r\n```\r\n\r\n> **Performance tip**: Wrap `auth.uid()` calls in `(select auth.uid())` in RLS policies for ~95% faster evaluation. See the `rls-policies` skill for the full pattern.\r\n\r\n### Column Consistency Rules\r\n\r\nColumn names MUST be consistent across all layers:\r\n\r\n- Column names in CRUD operations (e.g., `supabase.from('todos').insert({ text: '...' })`) MUST exactly match columns in schema.sql (e.g., `text text NOT NULL`).\r\n- TypeScript interface fields MUST map 1:1 to schema.sql columns.\r\n- If architecture.md DATABASE section says `task` but your interface uses `text`, pick ONE name and use it everywhere: schema.sql, TypeScript interface, and all CRUD operations.\r\n\r\n```\r\nschema.sql:           text text NOT NULL\r\nTypeScript interface: text: string\r\nInsert operation:     .insert({ text: '...' })\r\n                      ^^^^  ^^^^  ^^^^  — ALL must match\r\n```\r\n\r\n### Initial State for DB-Backed Components\r\n\r\nWhen a component fetches data from Supabase, initialize state with empty array `[]` and show loading state. NEVER hardcode demo objects with fake IDs in useState — any CRUD operation on fake IDs will fail because they don't exist in the database.\r\n\r\n```tsx\r\n// ✅ CORRECT — empty initial state + loading + useEffect fetch\r\nconst [todos, setTodos] = useState<Todo[]>([])\r\nconst [loading, setLoading] = useState(true)\r\n\r\nuseEffect(() => {\r\n  fetchTodos()\r\n}, [])\r\n\r\n// ❌ WRONG — fake IDs will crash on update/delete\r\nconst [todos, setTodos] = useState([\r\n  { id: '1', text: 'Fake todo', completed: false }\r\n])\r\n```\r\n\r\n### RULES\r\n\r\n1. **Only use when DATABASE section exists** in architecture.md\r\n2. **Never create .env.local** — it's auto-provisioned\r\n3. **Always create .env.local.example** — for documentation\r\n4. **Use 'use client' for data fetching** — with useState + useEffect\r\n5. **Handle errors gracefully** — check for error in response. Show user-facing error state for errors, empty state UI for empty results (empty results from RLS filtering are normal, not errors)\r\n6. **Use optimistic updates** — update local state before confirming\r\n7. **ALWAYS create schema.sql FIRST** when DATABASE section exists — before any component files\r\n8. **NEVER hardcode Supabase URL or anon key** — always use process.env\r\n9. **Column names in code MUST match column names in schema.sql** exactly\r\n10. **Initialize DB-backed state with empty array `[]`** — data loads via useEffect, never fake demo objects\r\n11. **Handle \"table not found\" gracefully** — catch BOTH `42P01` (PostgreSQL) AND `error.message?.includes('schema cache')` (PostgREST cache miss). Use the Database Readiness Pattern to show \"Setting up database...\" and auto-retry, not a raw error message\r\n12. **Column names in code MUST match schema.sql exactly** — if schema.sql says `created_at`, code must use `created_at` (not `createdAt`). If schema.sql says `user_id`, code must use `user_id` (not `userId`). TypeScript interfaces map 1:1 to SQL column names\r\n13. **For foreign key relationships, use PostgREST embedded select** — `.select('*, alias:fk_column(columns)')` instead of separate queries. Add optional relationship fields to TypeScript interfaces in `types/index.ts`\r\n14. **NEVER join auth.users via PostgREST** — the `auth` schema is not exposed via the REST API. Create a `profiles` table in the `public` schema and join that instead. See the `auth-setup` skill for the profiles table pattern\r\n15. **Always create indexes for FK columns in schema.sql** — every `_id` column referencing another table should have a corresponding `CREATE INDEX IF NOT EXISTS` statement. Without indexes, queries with RLS policies cause full table scans",
  },
  "debug-visual-issues": {
    name: "debug-visual-issues",
    description: "Fix text visibility, color clashes, and CSS variable issues. Use when user reports \"can't see\", \"invisible\", \"wrong color\", or visual display problems.",
    category: "chat",
    agents: ["chat"],
    instructions: "## When to Use\r\n- User says text is \"not visible\", \"can't see\", \"invisible\"\r\n- Colors are wrong or clashing\r\n- Elements not displaying properly\r\n- Dark mode / light mode issues\r\n\r\n## Instructions\r\n\r\n### Debugging Steps\r\n\r\n1. **FIRST read globals.css** — check what CSS variables are defined\r\n2. **Check the component** — is it using hardcoded colors that clash with the background?\r\n3. **Fix using CSS variables** — replace hardcoded colors with CSS variable references\r\n4. **Common cause**: Component uses `text-white` on a white background, or `text-black` on a dark background\r\n\r\n### Common Visibility Problems\r\n\r\n| Symptom | Likely Cause | Fix |\r\n|---------|-------------|-----|\r\n| Text invisible | Hardcoded color matches background | Use `text-foreground` |\r\n| Button text gone | `text-white` on light bg | Use `text-primary` or ensure bg is dark |\r\n| Card invisible | No background set | Add `bg-card` |\r\n| Dark mode broken | Only light mode colors | Add `.dark` CSS variables in globals.css |\r\n| Icon not showing | Wrong color on background | Use `text-foreground` |\r\n\r\n### Tailwind Theme Class Reference\r\n\r\nAlways read globals.css to see actual values, then use these Tailwind theme classes:\r\n```\r\ntext-foreground       — main text (adapts to theme)\r\ntext-muted-foreground — secondary text\r\ntext-primary          — accent/link text\r\nbg-background         — page background\r\nbg-card               — card/section background\r\nbg-primary            — accent background\r\nborder-primary        — accent borders\r\n```\r\n\r\n**NEVER use explicit CSS variable syntax** (e.g., `bg-[var(--varname)]`). Use the Tailwind theme classes above.\r\n\r\n### Dark Mode Debugging\r\n\r\n1. Check if globals.css has a `.dark` section with CSS variables\r\n2. Check if `@custom-variant dark (&:where(.dark, .dark *));` exists\r\n3. Ensure component uses CSS variables (not hardcoded colors) so dark mode works\r\n4. If no dark mode defined, add `.dark { ... }` to globals.css with appropriate values",
  },
  "design-system": {
    name: "design-system",
    description: "Choose color palette, aesthetic, and visual style decisions for distinctive app design. Use when determining the visual identity of an app.",
    category: "architecture",
    agents: ["architecture"],
    instructions: "## When to Use\r\n- Choosing aesthetic direction for a new app\r\n- Selecting color palette (light and dark mode)\r\n- Determining visual personality and signature element\r\n\r\n## Instructions\r\n\r\n### DESIGN REASONING\r\nBefore choosing aesthetic, answer these questions:\r\n\r\n1. **WHO is the user?**\r\n   - Consumer app → playful, soft-pastel, maximalist\r\n   - Business/B2B → editorial, minimal, luxury-refined\r\n   - Developer tools → brutally-minimal, industrial\r\n\r\n2. **WHAT is the mood?**\r\n   - Fun/casual → maximalist, playful, retro-futuristic\r\n   - Serious/professional → brutally-minimal, editorial, luxury-refined\r\n   - Creative/artistic → brutalist, art-deco\r\n\r\n3. **WHAT is the content?**\r\n   - Text-heavy → editorial (good typography focus)\r\n   - Visual-heavy → art-deco, maximalist (bold visuals)\r\n   - Data-focused → geometric, industrial (clear, structured)\r\n\r\n### AESTHETIC REFERENCE TABLE\r\n\r\n| Aesthetic | Best For | Spacing | Shadow | Radius |\r\n|-----------|----------|---------|--------|--------|\r\n| brutally-minimal | Productivity, dev tools | tight | flat | sharp |\r\n| maximalist | Entertainment, social | loose | dramatic | pill |\r\n| retro-futuristic | Games, tech demos | normal | elevated | rounded |\r\n| organic-natural | Health, wellness, eco | loose | subtle | rounded |\r\n| luxury-refined | Finance, premium SaaS | loose | dramatic | subtle |\r\n| playful | Kids, casual apps | normal | elevated | pill |\r\n| editorial | Blogs, news, portfolios | normal | subtle | subtle |\r\n| brutalist | Creative, art, experimental | tight | flat | sharp |\r\n| art-deco | Luxury, events, hospitality | normal | elevated | subtle |\r\n| soft-pastel | Wellness, beauty, lifestyle | loose | subtle | rounded |\r\n| industrial | Construction, manufacturing | tight | flat | sharp |\r\n\r\n### COLOR RULES\r\n1. NEVER use default white (#ffffff) or gray/slate colors\r\n2. Every color value MUST be actual hex (not \"#hex\" placeholder)\r\n3. Light and dark mode MUST both have complete color sets\r\n4. Signature colors should match the aesthetic personality\r\n\r\n### SIGNATURE ELEMENT\r\nEvery app MUST have a signature_element - one unique memorable visual feature:\r\n- Gradient background\r\n- Animated logo\r\n- Unique button shape\r\n- Distinctive card style\r\n- Custom cursor\r\n- Micro-interaction",
  },
  "edit-component": {
    name: "edit-component",
    description: "Safely modify existing components while preserving all existing code. Use when changing styles, editing JSX, or making targeted modifications.",
    category: "chat",
    agents: ["chat"],
    instructions: "## When to Use\r\n- Modifying existing components\r\n- Changing styles or visual appearance\r\n- Editing JSX structure\r\n- Any targeted modification to existing code\r\n\r\n## Instructions\r\n\r\n### CRITICAL: Code Preservation Rules\r\n\r\nWhen you write a file, you MUST include ALL existing code that wasn't meant to be changed:\r\n\r\n1. **Keep ALL imports** — Don't remove imports unless they become unused\r\n2. **Keep ALL functions** — Don't remove functions unless user asked to remove them\r\n3. **Keep ALL styles/CSS** — Don't remove CSS classes or styles\r\n4. **Keep ALL state/hooks** — Don't remove useState, useEffect, etc.\r\n5. **Keep ALL components** — Don't remove child components or JSX\r\n\r\n**BEFORE writing a file, mentally verify:**\r\n- [ ] All original imports are still there\r\n- [ ] All original functions/components are still there\r\n- [ ] All original CSS/styles are still there\r\n- [ ] Only the requested change was made\r\n\r\n### What NOT To Do\r\n\r\n- Do NOT remove existing CSS or styles (even if adding new styles)\r\n- Do NOT remove existing functions or components\r\n- Do NOT simplify or \"clean up\" code that wasn't asked to change\r\n- Do NOT write partial files with \"// ... rest of code\"\r\n- Do NOT create extra files user didn't ask for\r\n\r\n### Safe Editing Workflow\r\n\r\n1. **read_file** the target file first — ALWAYS get current version\r\n2. **read_file** related files (parent component, shared types)\r\n3. Identify the MINIMAL change needed\r\n4. **write_file** with COMPLETE file content (all original code + your change)\r\n5. Verify nothing was accidentally removed\r\n\r\n### Tailwind Theme Class Usage\r\n\r\nWhen changing colors or visual properties, use Tailwind theme classes:\r\n```\r\nbg-background         — page background\r\nbg-card               — card/section background\r\ntext-foreground       — main text\r\ntext-muted-foreground — subtle text\r\ntext-primary          — accent text\r\nbg-primary            — accent background\r\nborder-primary        — accent border\r\n```\r\n\r\n**NEVER use explicit CSS variable syntax** (e.g., `bg-[var(--varname)]`). Use the Tailwind theme classes above.",
  },
  "explain-code": {
    name: "explain-code",
    description: "Explain code to users in plain English. Use when user asks \"how does this work\", \"what does this do\", or \"explain\" about their code.",
    category: "chat",
    agents: ["chat"],
    instructions: "## When to Use\r\n- User asks \"how does this work?\"\r\n- User asks \"what does this code do?\"\r\n- User asks \"explain\" about a component or pattern\r\n- User asks \"why\" about an implementation choice\r\n\r\n## Instructions\r\n\r\n### Explanation Approach\r\n\r\n1. **Read the relevant file(s)** — use read_file to get current code\r\n2. **DO NOT modify any code** — explanation only\r\n3. **Explain in plain English** — avoid jargon, be clear\r\n4. **Structure your explanation**:\r\n   - What the component/function does (high level)\r\n   - How it works (key parts)\r\n   - Why it's structured that way (if relevant)\r\n\r\n### Explanation Format\r\n\r\nKeep explanations concise and structured:\r\n- Start with a one-sentence summary\r\n- Break down key parts\r\n- Highlight any patterns or conventions used\r\n- Note any dependencies or related files\r\n\r\n### RULES\r\n- NEVER modify files when explaining\r\n- Read ALL relevant files before explaining\r\n- Be concise — users want understanding, not lectures\r\n- Point out important patterns (state management, data flow)",
  },
  "fix-bug": {
    name: "fix-bug",
    description: "Debug and fix code issues using root cause analysis. Use when user reports errors, crashes, broken functionality, or unexpected behavior.",
    category: "chat",
    agents: ["chat"],
    instructions: "## When to Use\r\n- User reports something \"not working\", \"broken\", \"error\"\r\n- Application crashes or shows error messages\r\n- Unexpected behavior (wrong data, missing updates)\r\n- Console errors or build failures\r\n\r\n## Instructions\r\n\r\n### Root Cause Analysis Methodology\r\n\r\n1. **Think through the ROOT CAUSE** — don't just patch symptoms\r\n2. **Read ALL related files** (the component, its parent, shared state, types)\r\n3. **Trace the data flow**: where does the state come from? How does it update?\r\n4. **Fix the actual cause**, not just the visible symptom\r\n5. **Test mentally**: does your fix handle all edge cases?\r\n\r\n### Investigation Steps\r\n\r\n1. **Reproduce mentally** — what exactly does the user see?\r\n2. **Read the component** — find the code related to the broken behavior\r\n3. **Read related files** — parent component, data source, types, utilities\r\n4. **Trace data flow**:\r\n   - Where is the data defined?\r\n   - How does it get to this component? (props, state, context)\r\n   - What triggers updates?\r\n   - Are there async operations that might race?\r\n5. **Identify the root cause** — what's actually wrong?\r\n6. **Fix precisely** — change only what's needed\r\n\r\n### Common Bug Patterns\r\n\r\n| Bug Type | Symptoms | Common Cause | Fix |\r\n|----------|----------|-------------|-----|\r\n| Hydration mismatch | Console error, flicker | Math.random/Date.now in render | Move to useEffect |\r\n| Stale state | Old data displayed | Missing dependency in useEffect | Add dependencies |\r\n| Missing 'use client' | \"useState is not a function\" | Server component using hooks | Add 'use client' |\r\n| Async in client | Component crashes | `async function` with 'use client' | Remove async, use useEffect |\r\n| Infinite loop | Page freezes | setState in useEffect without deps | Add dependency array |\r\n| Props not updating | UI doesn't change | Object reference comparison | Spread into new object |\r\n| Event not firing | Click doesn't work | Nested interactive elements | Fix nesting hierarchy |\r\n\r\n### RULES\r\n- NEVER just patch symptoms — find the real cause\r\n- ALWAYS read ALL related files before making changes\r\n- FIX the root cause, even if it's in a different file than expected\r\n- PRESERVE all existing code — only change what's needed for the fix",
  },
  "form-builder": {
    name: "form-builder",
    description: "Build forms with react-hook-form and zod validation. Use when creating forms, input validation, or form submission handling.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Creating forms with validation\r\n- Handling form submission\r\n- Building multi-step forms\r\n- Input validation with error display\r\n\r\n## Instructions\r\n\r\n### Basic Form Pattern (react-hook-form + zod)\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useForm } from 'react-hook-form'\r\nimport { zodResolver } from '@hookform/resolvers/zod'\r\nimport { z } from 'zod'\r\nimport { Button } from '@/components/ui/button'\r\nimport { Input } from '@/components/ui/input'\r\nimport { Label } from '@/components/ui/label'\r\n\r\n// 1. Define schema\r\nconst formSchema = z.object({\r\n  name: z.string().min(2, 'Name must be at least 2 characters'),\r\n  email: z.string().email('Invalid email address'),\r\n  message: z.string().min(10, 'Message must be at least 10 characters'),\r\n})\r\n\r\ntype FormData = z.infer<typeof formSchema>\r\n\r\n// 2. Create form component\r\nexport function ContactForm() {\r\n  const {\r\n    register,\r\n    handleSubmit,\r\n    formState: { errors, isSubmitting },\r\n    reset,\r\n  } = useForm<FormData>({\r\n    resolver: zodResolver(formSchema),\r\n  })\r\n\r\n  const onSubmit = async (data: FormData) => {\r\n    console.log(data)\r\n    // API call here\r\n    reset()\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-4\">\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"name\">Name</Label>\r\n        <Input id=\"name\" {...register('name')} />\r\n        {errors.name && (\r\n          <p className=\"text-sm text-red-500\">{errors.name.message}</p>\r\n        )}\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"email\">Email</Label>\r\n        <Input id=\"email\" type=\"email\" {...register('email')} />\r\n        {errors.email && (\r\n          <p className=\"text-sm text-red-500\">{errors.email.message}</p>\r\n        )}\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"message\">Message</Label>\r\n        <textarea\r\n          id=\"message\"\r\n          {...register('message')}\r\n          className=\"w-full p-2 border rounded-md\"\r\n          rows={4}\r\n        />\r\n        {errors.message && (\r\n          <p className=\"text-sm text-red-500\">{errors.message.message}</p>\r\n        )}\r\n      </div>\r\n\r\n      <Button type=\"submit\" disabled={isSubmitting}>\r\n        {isSubmitting ? 'Sending...' : 'Send Message'}\r\n      </Button>\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n### Common Zod Schema Patterns\r\n\r\n```tsx\r\nimport { z } from 'zod'\r\n\r\n// String validations\r\nconst stringSchema = z.object({\r\n  required: z.string().min(1, 'Required'),\r\n  email: z.string().email('Invalid email'),\r\n  url: z.string().url('Invalid URL'),\r\n  minLength: z.string().min(5, 'Must be at least 5 characters'),\r\n  maxLength: z.string().max(100, 'Must be at most 100 characters'),\r\n  regex: z.string().regex(/^[A-Z]/, 'Must start with uppercase'),\r\n})\r\n\r\n// Number validations\r\nconst numberSchema = z.object({\r\n  positive: z.number().positive('Must be positive'),\r\n  range: z.number().min(1).max(100),\r\n  integer: z.number().int('Must be a whole number'),\r\n})\r\n\r\n// Optional fields\r\nconst optionalSchema = z.object({\r\n  optional: z.string().optional(),\r\n  nullable: z.string().nullable(),\r\n  withDefault: z.string().default('default value'),\r\n})\r\n\r\n// Enum/select fields\r\nconst enumSchema = z.object({\r\n  status: z.enum(['draft', 'published', 'archived']),\r\n  role: z.enum(['admin', 'user', 'guest']),\r\n})\r\n\r\n// Password with confirmation\r\nconst passwordSchema = z.object({\r\n  password: z.string().min(8, 'Password must be at least 8 characters'),\r\n  confirmPassword: z.string(),\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n  message: \"Passwords don't match\",\r\n  path: ['confirmPassword'],\r\n})\r\n```\r\n\r\n### Select Field Pattern (with react-hook-form)\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { Controller, useForm } from 'react-hook-form'\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'\r\n\r\ninterface FormData {\r\n  category: string\r\n}\r\n\r\nexport function SelectForm() {\r\n  const { control, handleSubmit } = useForm<FormData>()\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(console.log)}>\r\n      <Controller\r\n        name=\"category\"\r\n        control={control}\r\n        render={({ field }) => (\r\n          <Select onValueChange={field.onChange} value={field.value}>\r\n            <SelectTrigger>\r\n              <SelectValue placeholder=\"Select category\" />\r\n            </SelectTrigger>\r\n            <SelectContent>\r\n              <SelectItem value=\"tech\">Technology</SelectItem>\r\n              <SelectItem value=\"health\">Health</SelectItem>\r\n              <SelectItem value=\"finance\">Finance</SelectItem>\r\n            </SelectContent>\r\n          </Select>\r\n        )}\r\n      />\r\n      <Button type=\"submit\">Submit</Button>\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n### Simple Form (without react-hook-form)\r\n\r\nFor simple forms, useState is sufficient:\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useState } from 'react'\r\nimport { Button } from '@/components/ui/button'\r\nimport { Input } from '@/components/ui/input'\r\n\r\nexport function SimpleForm() {\r\n  const [name, setName] = useState('')\r\n  const [error, setError] = useState('')\r\n\r\n  const handleSubmit = (e: React.FormEvent) => {\r\n    e.preventDefault()\r\n    if (name.length < 2) {\r\n      setError('Name must be at least 2 characters')\r\n      return\r\n    }\r\n    setError('')\r\n    console.log('Submitted:', name)\r\n    setName('')\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit} className=\"space-y-4\">\r\n      <div>\r\n        <Input\r\n          value={name}\r\n          onChange={(e) => setName(e.target.value)}\r\n          placeholder=\"Enter name\"\r\n        />\r\n        {error && <p className=\"text-sm text-red-500 mt-1\">{error}</p>}\r\n      </div>\r\n      <Button type=\"submit\">Submit</Button>\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n### Error Display Pattern\r\n\r\n```tsx\r\n// Inline error below input\r\n{errors.fieldName && (\r\n  <p className=\"text-sm text-red-500 mt-1\">{errors.fieldName.message}</p>\r\n)}\r\n\r\n// Error with icon\r\n{errors.fieldName && (\r\n  <div className=\"flex items-center gap-2 text-red-500 text-sm mt-1\">\r\n    <AlertCircle className=\"h-4 w-4\" />\r\n    <span>{errors.fieldName.message}</span>\r\n  </div>\r\n)}\r\n\r\n// Error styling on input\r\n<Input\r\n  {...register('email')}\r\n  className={errors.email ? 'border-red-500 focus:ring-red-500' : ''}\r\n/>\r\n```\r\n\r\n### Form with Loading State\r\n\r\n```tsx\r\nconst [isLoading, setIsLoading] = useState(false)\r\n\r\nconst onSubmit = async (data: FormData) => {\r\n  setIsLoading(true)\r\n  try {\r\n    await submitToAPI(data)\r\n    reset()\r\n  } catch (error) {\r\n    console.error(error)\r\n  } finally {\r\n    setIsLoading(false)\r\n  }\r\n}\r\n\r\n<Button type=\"submit\" disabled={isLoading}>\r\n  {isLoading ? (\r\n    <>\r\n      <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\r\n      Submitting...\r\n    </>\r\n  ) : (\r\n    'Submit'\r\n  )}\r\n</Button>\r\n```\r\n\r\n### Required Packages\r\n\r\nIf using react-hook-form:\r\n```\r\nreact-hook-form @hookform/resolvers zod\r\n```\r\n\r\n### RULES\r\n\r\n1. Always add `'use client'` for form components\r\n2. Use zod for validation when form has multiple fields\r\n3. Use useState for simple single-field forms\r\n4. Always show validation errors near the input\r\n5. Disable submit button during submission\r\n6. Clear form after successful submission",
  },
  "hydration-safety": {
    name: "hydration-safety",
    description: "Prevent SSR/client hydration mismatches. Use when creating components with hooks, state, or browser APIs. CRITICAL for any useState, useEffect, or window access.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Creating any component using hooks (useState, useEffect, useRef)\r\n- Accessing browser APIs (window, localStorage, document)\r\n- Using dynamic values in initial render (Date.now, Math.random)\r\n- Building interactive components with event handlers\r\n\r\n## Instructions\r\n\r\n### HYDRATION SAFETY (ZERO TOLERANCE)\r\n\r\nNEVER use these in initial render or useState initializers — they differ server vs client:\r\n\r\n| API | Problem | Solution |\r\n|-----|---------|----------|\r\n| `Math.random()` | Different on server/client | Use pre-defined string IDs |\r\n| `Date.now()` | Different timestamp | Use fixed value or useEffect |\r\n| `window.*` | Doesn't exist on server | Wrap in useEffect |\r\n| `localStorage.*` | Doesn't exist on server | Wrap in useEffect |\r\n| `document.*` | Doesn't exist on server | Wrap in useEffect |\r\n\r\n### Browser API Access Pattern\r\n\r\n```tsx\r\n// ❌ WRONG - hydration error\r\nconst width = window.innerWidth\r\nconst stored = localStorage.getItem('key')\r\n\r\n// ✅ CORRECT - access in useEffect\r\nconst [width, setWidth] = useState(0)\r\nconst [stored, setStored] = useState<string | null>(null)\r\n\r\nuseEffect(() => {\r\n  setWidth(window.innerWidth)\r\n  setStored(localStorage.getItem('key'))\r\n}, [])\r\n```\r\n\r\n### ID Generation Pattern\r\n\r\n```tsx\r\n// ❌ WRONG - hydration error (different IDs on server/client)\r\nconst items = data.map(item => ({\r\n  ...item,\r\n  id: Math.random().toString(36)\r\n}))\r\n\r\n// ✅ CORRECT - deterministic IDs\r\nconst items = data.map((item, index) => ({\r\n  ...item,\r\n  id: `item-${index}`\r\n}))\r\n\r\n// ✅ CORRECT - pre-defined IDs\r\nconst ITEMS = [\r\n  { id: 'item-1', name: 'First' },\r\n  { id: 'item-2', name: 'Second' },\r\n]\r\n```\r\n\r\n### Date Handling Pattern\r\n\r\n```tsx\r\n// ❌ WRONG - hydration error\r\nconst [timestamp, setTimestamp] = useState(Date.now())\r\n\r\n// ✅ CORRECT - initialize empty, set in useEffect\r\nconst [timestamp, setTimestamp] = useState<number | null>(null)\r\nuseEffect(() => {\r\n  setTimestamp(Date.now())\r\n}, [])\r\n\r\n// ✅ CORRECT - use fixed initial value if needed\r\nconst [timestamp, setTimestamp] = useState(0)\r\nuseEffect(() => {\r\n  setTimestamp(Date.now())\r\n}, [])\r\n```\r\n\r\n### Game Cards Pattern (Deterministic)\r\n\r\n```tsx\r\n// ❌ WRONG - random shuffling causes hydration error\r\nconst cards = [...pairs].sort(() => Math.random() - 0.5)\r\n\r\n// ✅ CORRECT - deterministic sort, shuffle in useEffect if needed\r\nconst generateCards = () => {\r\n  const pairs = ['🎮', '🎯', '🎲', '🎪', '🎨', '🎭', '🎸', '🎺']\r\n  return pairs.flatMap((emoji, i) => [\r\n    { id: `card-${emoji}-a`, emoji, flipped: false, matched: false },\r\n    { id: `card-${emoji}-b`, emoji, flipped: false, matched: false },\r\n  ]).sort((a, b) => a.id.localeCompare(b.id)) // Deterministic sort\r\n}\r\n\r\n// If you need shuffling, do it in useEffect:\r\nconst [cards, setCards] = useState(generateCards())\r\nuseEffect(() => {\r\n  setCards(prev => [...prev].sort(() => Math.random() - 0.5))\r\n}, [])\r\n```\r\n\r\n### ThemeToggle Pattern (Hydration-Safe)\r\n\r\n```tsx\r\n'use client'\r\nimport { useEffect, useState } from 'react'\r\nimport { Moon, Sun } from 'lucide-react'\r\nimport { Button } from '@/components/ui/button'\r\n\r\nexport function ThemeToggle() {\r\n  const [dark, setDark] = useState(false)\r\n\r\n  useEffect(() => {\r\n    // Only access window after mount\r\n    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches\r\n    setDark(prefersDark)\r\n    if (prefersDark) document.documentElement.classList.add('dark')\r\n  }, [])\r\n\r\n  const toggle = () => {\r\n    setDark(prev => !prev)\r\n    document.documentElement.classList.toggle('dark')\r\n  }\r\n\r\n  return (\r\n    <Button variant=\"ghost\" size=\"icon\" onClick={toggle}>\r\n      {dark ? <Sun className=\"h-5 w-5\" /> : <Moon className=\"h-5 w-5\" />}\r\n    </Button>\r\n  )\r\n}\r\n```\r\n\r\n### suppressHydrationWarning Usage\r\n\r\nFor edge cases where content MUST differ (e.g., timestamps), use suppressHydrationWarning:\r\n\r\n```tsx\r\n// Use sparingly - only when difference is intentional\r\n<html lang=\"en\" suppressHydrationWarning>\r\n  <body suppressHydrationWarning>\r\n    {children}\r\n  </body>\r\n</html>\r\n```\r\n\r\n### useSyncExternalStore Error\r\n\r\n**\"getServerSnapshot should be cached\" error** means the code uses `useSyncExternalStore` incorrectly. **The fix is to REPLACE the custom store with standard React patterns:**\r\n\r\n```tsx\r\n// ❌ WRONG - causes SSR hydration error\r\nimport { useSyncExternalStore } from 'react'\r\nconst store = { state: [], listeners: new Set() }\r\nexport function useStore() {\r\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)\r\n}\r\n\r\n// ✅ CORRECT - Replace with useState or Context\r\n'use client'\r\nimport { useState, createContext, useContext } from 'react'\r\n\r\n// Option 1: Simple useState in component\r\nconst [items, setItems] = useState(INITIAL_DATA)\r\n\r\n// Option 2: Context for shared state\r\nconst StoreContext = createContext(null)\r\nexport function StoreProvider({ children }) {\r\n  const [state, setState] = useState(INITIAL_STATE)\r\n  return <StoreContext.Provider value={{ state, setState }}>{children}</StoreContext.Provider>\r\n}\r\nexport function useStore() {\r\n  return useContext(StoreContext)\r\n}\r\n```\r\n\r\n**When fixing this error:**\r\n1. Remove any useSyncExternalStore imports\r\n2. Remove custom subscribe/getSnapshot/getServerSnapshot functions\r\n3. Replace with useState or Context + useState pattern\r\n4. Update all components using the store to use the new pattern\r\n\r\n### Nested Interactive Elements\r\n\r\nNever put interactive elements inside each other — this causes hydration mismatches:\r\n\r\n```tsx\r\n// ❌ WRONG - nested interactive elements\r\n<a href=\"/page\">\r\n  <button onClick={handleClick}>Click me</button>\r\n</a>\r\n\r\n// ❌ WRONG - button wrapping a link\r\n<button>\r\n  <a href=\"/page\">Go to page</a>\r\n</button>\r\n\r\n// ✅ CORRECT - use one or the other\r\n<button onClick={() => router.push('/page')}>Go to page</button>\r\n\r\n// ✅ CORRECT - style link as button\r\n<a href=\"/page\" className=\"bg-primary px-4 py-2 rounded\">Go to page</a>\r\n```\r\n\r\n### RULES CHECKLIST\r\n\r\nBefore completing any component, verify:\r\n- [ ] No Math.random() in render or useState initializer\r\n- [ ] No Date.now() in render or useState initializer\r\n- [ ] No window/localStorage/document access outside useEffect\r\n- [ ] All array IDs are deterministic (not random)\r\n- [ ] All shuffling/randomization happens in useEffect\r\n- [ ] No useSyncExternalStore (use useState or Context instead)\r\n- [ ] No nested interactive elements (<button> inside <a> or vice versa)",
  },
  "layout-grid": {
    name: "layout-grid",
    description: "Create page layouts with CSS Grid and Flexbox. Use when building page structures, card grids, or responsive containers.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Building page layouts (header, main, footer)\r\n- Creating card grids\r\n- Designing responsive containers\r\n- Organizing sections on landing pages\r\n\r\n## Instructions\r\n\r\n### Page Layout Pattern\r\n\r\n```tsx\r\nexport default function Page() {\r\n  return (\r\n    <div className=\"min-h-screen bg-background\">\r\n      {/* Header */}\r\n      <header className=\"border-b border-border bg-card px-6 py-4 shadow-sm\">\r\n        <div className=\"container mx-auto flex items-center justify-between\">\r\n          <h1 className=\"font-display text-2xl font-bold text-foreground\">Logo</h1>\r\n          <nav className=\"flex gap-6\">\r\n            <a href=\"#\" className=\"text-muted-foreground hover:text-foreground\">Features</a>\r\n            <a href=\"#\" className=\"text-muted-foreground hover:text-foreground\">Pricing</a>\r\n          </nav>\r\n        </div>\r\n      </header>\r\n\r\n      {/* Main Content */}\r\n      <main className=\"container mx-auto px-6 py-8\">\r\n        <div className=\"grid gap-6\">\r\n          {/* content */}\r\n        </div>\r\n      </main>\r\n\r\n      {/* Footer */}\r\n      <footer className=\"border-t border-border bg-card px-6 py-8\">\r\n        <div className=\"container mx-auto text-center text-muted-foreground\">\r\n          &copy; 2024 Company\r\n        </div>\r\n      </footer>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### Grid Patterns\r\n\r\n| Use Case | Classes | Description |\r\n|----------|---------|-------------|\r\n| 3-column | `grid grid-cols-1 md:grid-cols-3 gap-6` | Cards, features |\r\n| 2-column | `grid grid-cols-1 md:grid-cols-2 gap-8` | Split layouts |\r\n| 4-column | `grid grid-cols-2 md:grid-cols-4 gap-4` | Image gallery |\r\n| Auto-fill | `grid grid-cols-[repeat(auto-fill,minmax(280px,1fr))] gap-6` | Flexible cards |\r\n\r\n### Features Grid Section\r\n\r\n```tsx\r\n<section className=\"py-20 px-4 bg-background\">\r\n  <div className=\"max-w-6xl mx-auto\">\r\n    <h2 className=\"font-display text-3xl md:text-4xl font-bold text-center text-foreground mb-12\">\r\n      Features\r\n    </h2>\r\n    <div className=\"grid md:grid-cols-3 gap-8\">\r\n      {features.map((feature) => (\r\n        <div key={feature.id} className=\"bg-card p-6 rounded-xl shadow-md hover:shadow-lg transition-shadow\">\r\n          <div className=\"w-12 h-12 bg-primary/10 rounded-lg flex items-center justify-center mb-4\">\r\n            {feature.icon}\r\n          </div>\r\n          <h3 className=\"font-display text-xl font-semibold text-foreground mb-2\">\r\n            {feature.title}\r\n          </h3>\r\n          <p className=\"text-muted-foreground\">\r\n            {feature.description}\r\n          </p>\r\n        </div>\r\n      ))}\r\n    </div>\r\n  </div>\r\n</section>\r\n```\r\n\r\n### Flexbox Patterns\r\n\r\n| Use Case | Classes | Description |\r\n|----------|---------|-------------|\r\n| Center content | `flex items-center justify-center` | Center both axes |\r\n| Space between | `flex items-center justify-between` | Header nav |\r\n| Column stack | `flex flex-col gap-4` | Vertical list |\r\n| Wrap cards | `flex flex-wrap gap-4` | Flexible cards |\r\n\r\n### Hero Section Layouts\r\n\r\n**Centered Hero:**\r\n```tsx\r\n<section className=\"min-h-[80vh] flex flex-col items-center justify-center text-center px-4 bg-background\">\r\n  <h1 className=\"font-display text-5xl md:text-7xl font-bold text-foreground mb-6\">\r\n    {headline}\r\n  </h1>\r\n  <p className=\"text-xl text-muted-foreground max-w-2xl mb-8\">\r\n    {subheadline}\r\n  </p>\r\n  <div className=\"flex gap-4\">\r\n    <Button>{primaryCTA}</Button>\r\n    <Button variant=\"outline\">{secondaryCTA}</Button>\r\n  </div>\r\n</section>\r\n```\r\n\r\n**Split Hero (content left, image right):**\r\n```tsx\r\n<section className=\"min-h-[80vh] grid md:grid-cols-2 gap-12 items-center px-4 md:px-12 bg-background\">\r\n  <div className=\"space-y-6\">\r\n    <h1 className=\"font-display text-4xl md:text-6xl font-bold text-foreground\">\r\n      {headline}\r\n    </h1>\r\n    <p className=\"text-lg text-muted-foreground\">\r\n      {subheadline}\r\n    </p>\r\n    <div className=\"flex gap-4\">\r\n      <Button>{primaryCTA}</Button>\r\n      <Button variant=\"outline\">{secondaryCTA}</Button>\r\n    </div>\r\n  </div>\r\n  <div className=\"bg-card rounded-2xl aspect-video flex items-center justify-center\">\r\n    {/* Image or visual content */}\r\n  </div>\r\n</section>\r\n```\r\n\r\n### Container Patterns\r\n\r\n```tsx\r\n// Standard centered container\r\n<div className=\"max-w-6xl mx-auto px-4\">\r\n\r\n// Full width with padding\r\n<div className=\"w-full px-4 md:px-8 lg:px-12\">\r\n\r\n// Narrow content (articles, forms)\r\n<div className=\"max-w-2xl mx-auto px-4\">\r\n\r\n// Wide content (dashboards)\r\n<div className=\"max-w-7xl mx-auto px-4\">\r\n```\r\n\r\n### Section Spacing\r\n\r\n```tsx\r\n// Standard section spacing\r\n<section className=\"py-20 px-4\">\r\n\r\n// Tight spacing (spacing_scale: tight)\r\n<section className=\"py-12 px-4\">\r\n\r\n// Loose spacing (spacing_scale: loose)\r\n<section className=\"py-24 px-4 md:py-32\">\r\n```\r\n\r\n### Visual Rhythm (Alternating Backgrounds)\r\n\r\n```tsx\r\n<div className=\"min-h-screen bg-background\">\r\n  <section className=\"py-20 bg-background\">\r\n    {/* Section 1 */}\r\n  </section>\r\n  <section className=\"py-20 bg-card\">\r\n    {/* Section 2 - alternate background */}\r\n  </section>\r\n  <section className=\"py-20 bg-background\">\r\n    {/* Section 3 */}\r\n  </section>\r\n</div>\r\n```\r\n\r\n### Dashboard Layout\r\n\r\n```tsx\r\n<div className=\"min-h-screen bg-background\">\r\n  <div className=\"flex\">\r\n    {/* Sidebar */}\r\n    <aside className=\"w-64 border-r border-border bg-card min-h-screen p-4\">\r\n      <nav className=\"space-y-2\">\r\n        {navItems.map(item => (\r\n          <a key={item.id} href={item.href} className=\"block px-4 py-2 rounded-lg hover:bg-primary/10\">\r\n            {item.label}\r\n          </a>\r\n        ))}\r\n      </nav>\r\n    </aside>\r\n\r\n    {/* Main Content */}\r\n    <main className=\"flex-1 p-8\">\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6\">\r\n        {/* Stats cards */}\r\n      </div>\r\n    </main>\r\n  </div>\r\n</div>\r\n```\r\n\r\n### RULES\r\n\r\n1. Use CSS Grid for 2D layouts (rows AND columns)\r\n2. Use Flexbox for 1D layouts (row OR column)\r\n3. Always use Tailwind theme classes for colors (bg-primary, text-foreground, bg-card, etc.)\r\n4. Use container with mx-auto for centered content\r\n5. Apply consistent section spacing (py-16, py-20, or py-24)\r\n6. Alternate backgrounds for visual rhythm",
  },
  "localstorage-persistence": {
    name: "localstorage-persistence",
    description: "Persist data to localStorage for apps without a database. Use when app needs to save data client-side without Supabase.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- App needs to save user data BUT does NOT have a DATABASE section in architecture.md\r\n- User explicitly says \"no database\" or \"no Supabase\"\r\n- Simple persistence: preferences, settings, small data sets\r\n- Single-user apps that don't need server-side storage\r\n\r\n## When NOT to Use\r\n- Architecture.md has a DATABASE section (use database-queries skill instead)\r\n- App needs multi-user data sharing\r\n- Data exceeds ~5MB\r\n- App requires server-side persistence or real-time sync\r\n\r\n## Instructions\r\n\r\n### useLocalStorage Hook (Hydration-Safe)\r\n\r\nCreate this hook in `lib/use-local-storage.ts`:\r\n\r\n```typescript\r\n'use client'\r\n\r\nimport { useState, useEffect } from 'react'\r\n\r\nexport function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T | ((prev: T) => T)) => void] {\r\n  // Initialize with initialValue to avoid hydration mismatch\r\n  const [storedValue, setStoredValue] = useState<T>(initialValue)\r\n\r\n  // Load from localStorage after mount (client-side only)\r\n  useEffect(() => {\r\n    if (typeof window === 'undefined') return\r\n\r\n    try {\r\n      const item = window.localStorage.getItem(key)\r\n      if (item) {\r\n        setStoredValue(JSON.parse(item))\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error reading localStorage key \"${key}\":`, error)\r\n    }\r\n  }, [key])\r\n\r\n  // Setter that also saves to localStorage\r\n  const setValue = (value: T | ((prev: T) => T)) => {\r\n    try {\r\n      const valueToStore = value instanceof Function ? value(storedValue) : value\r\n      setStoredValue(valueToStore)\r\n\r\n      if (typeof window !== 'undefined') {\r\n        window.localStorage.setItem(key, JSON.stringify(valueToStore))\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error setting localStorage key \"${key}\":`, error)\r\n    }\r\n  }\r\n\r\n  return [storedValue, setValue]\r\n}\r\n```\r\n\r\n### Usage Patterns\r\n\r\n**Simple value persistence (theme, preferences):**\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useLocalStorage } from '@/lib/use-local-storage'\r\n\r\nexport function ThemeToggle() {\r\n  const [theme, setTheme] = useLocalStorage<'light' | 'dark'>('myapp-theme', 'light')\r\n\r\n  return (\r\n    <button onClick={() => setTheme(prev => prev === 'light' ? 'dark' : 'light')}>\r\n      Current: {theme}\r\n    </button>\r\n  )\r\n}\r\n```\r\n\r\n**Array/object persistence (todo list, notes):**\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useState } from 'react'\r\nimport { useLocalStorage } from '@/lib/use-local-storage'\r\n\r\ninterface Todo {\r\n  id: string\r\n  text: string\r\n  completed: boolean\r\n}\r\n\r\nexport function TodoList() {\r\n  const [todos, setTodos] = useLocalStorage<Todo[]>('myapp-todos', [\r\n    { id: '1', text: 'Welcome todo', completed: false },\r\n  ])\r\n  const [input, setInput] = useState('')\r\n\r\n  const addTodo = () => {\r\n    if (!input.trim()) return\r\n    setTodos(prev => [...prev, {\r\n      id: `todo-${Date.now()}`,\r\n      text: input,\r\n      completed: false,\r\n    }])\r\n    setInput('')\r\n  }\r\n\r\n  const toggleTodo = (id: string) => {\r\n    setTodos(prev => prev.map(t =>\r\n      t.id === id ? { ...t, completed: !t.completed } : t\r\n    ))\r\n  }\r\n\r\n  const deleteTodo = (id: string) => {\r\n    setTodos(prev => prev.filter(t => t.id !== id))\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <input value={input} onChange={e => setInput(e.target.value)} />\r\n      <button onClick={addTodo}>Add</button>\r\n      <ul>\r\n        {todos.map(todo => (\r\n          <li key={todo.id}>\r\n            <span\r\n              style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\r\n              onClick={() => toggleTodo(todo.id)}\r\n            >\r\n              {todo.text}\r\n            </span>\r\n            <button onClick={() => deleteTodo(todo.id)}>Delete</button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n**Clearing data:**\r\n\r\n```tsx\r\nconst clearAll = () => {\r\n  if (typeof window !== 'undefined') {\r\n    window.localStorage.removeItem('myapp-todos')\r\n  }\r\n  setTodos([])\r\n}\r\n```\r\n\r\n### Integration with Context (Shared localStorage State)\r\n\r\nWhen multiple components need the same localStorage state, combine with Context:\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { createContext, useContext, ReactNode } from 'react'\r\nimport { useLocalStorage } from '@/lib/use-local-storage'\r\n\r\ninterface Settings {\r\n  theme: 'light' | 'dark'\r\n  fontSize: number\r\n}\r\n\r\ninterface SettingsContextType {\r\n  settings: Settings\r\n  updateSettings: (settings: Settings) => void\r\n}\r\n\r\nconst SettingsContext = createContext<SettingsContextType | null>(null)\r\n\r\nexport function SettingsProvider({ children }: { children: ReactNode }) {\r\n  const [settings, setSettings] = useLocalStorage<Settings>('myapp-settings', {\r\n    theme: 'light',\r\n    fontSize: 16,\r\n  })\r\n\r\n  return (\r\n    <SettingsContext.Provider value={{ settings, updateSettings: setSettings }}>\r\n      {children}\r\n    </SettingsContext.Provider>\r\n  )\r\n}\r\n\r\nexport function useSettings() {\r\n  const context = useContext(SettingsContext)\r\n  if (!context) throw new Error('useSettings must be used within SettingsProvider')\r\n  return context\r\n}\r\n```\r\n\r\n### RULES\r\n\r\n1. **NEVER use when DATABASE section exists** — use database-queries skill instead\r\n2. **Always wrap localStorage access in `typeof window !== 'undefined'` check** — prevents SSR errors\r\n3. **Always handle JSON.parse errors gracefully** — localStorage may contain corrupted data\r\n4. **Use descriptive key names prefixed with app name** (e.g., `myapp-todos`, `myapp-settings`)\r\n5. **Initialize state from localStorage in useEffect, not during render** — hydration safety",
  },
  "modify-schema": {
    name: "modify-schema",
    description: "Safely modify database schema. Use when user requests adding columns, tables, RLS policies, or fixing schema issues.",
    category: "chat",
    agents: ["chat"],
    instructions: "## When to Use\r\n- User asks to add a column or field to an existing table\r\n- User asks to add a new table\r\n- User asks to modify or add RLS policies\r\n- User asks to fix schema issues (missing columns, wrong types)\r\n- User asks to drop a column or table (destructive — warn first)\r\n\r\n## Instructions\r\n\r\n### Safe Modification Workflow\r\n\r\n1. **Always read schema.sql first** — use `read_file(\"schema.sql\")` to get the current state\r\n2. **Identify what needs to change** — compare user request against existing schema\r\n3. **Use additive patterns** — prefer `IF NOT EXISTS` and `IF EXISTS` for idempotency\r\n4. **Update both CREATE TABLE and add ALTER TABLE** — keep the CREATE TABLE definition consistent with the actual state, and add ALTER TABLE statements for the change\r\n5. **Always preserve NOTIFY pgrst as the last line** — this reloads the PostgREST schema cache\r\n6. **After modifying schema.sql, update all dependent code:**\r\n   - TypeScript interfaces to match new columns\r\n   - `.select()` queries to include new columns\r\n   - INSERT operations to include new columns where needed\r\n   - UI components to display/input new fields\r\n\r\n### Additive Patterns (Safe — Use These)\r\n\r\n**Add a column to an existing table:**\r\n```sql\r\n-- Update the CREATE TABLE to include the new column for consistency\r\n-- Then add ALTER TABLE for the actual migration:\r\nALTER TABLE table_name ADD COLUMN IF NOT EXISTS column_name type;\r\n```\r\n\r\n**Add a new table:**\r\n```sql\r\n-- Place in correct FK order (parent tables before child tables)\r\nCREATE TABLE IF NOT EXISTS new_table (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  created_at timestamptz DEFAULT now(),\r\n  -- columns here\r\n);\r\n```\r\n\r\n**Add an RLS policy:**\r\n```sql\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'table_name' AND policyname = 'Policy name'\r\n  ) THEN\r\n    CREATE POLICY \"Policy name\" ON table_name\r\n      FOR ALL\r\n      USING (true)\r\n      WITH CHECK (true);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**Add SECURITY DEFINER helper (when adding 3rd+ table with FKs):**\r\n\r\nIf your modification adds a table that brings the total to 3+ tables with foreign key chains, you MUST also add a SECURITY DEFINER helper function:\r\n\r\n```sql\r\n-- Create AFTER all tables, BEFORE policies\r\ncreate or replace function get_user_workspace_ids()\r\nreturns setof uuid\r\nlanguage sql\r\nsecurity definer\r\nset search_path = public\r\nas $$\r\n  select id from workspaces where owner_id = (select auth.uid())\r\n  union\r\n  select workspace_id from workspace_members where user_id = (select auth.uid());\r\n$$;\r\n```\r\n\r\nAdapt the function name and query to match your schema's ownership/membership pattern.\r\n\r\n**Add an index:**\r\n```sql\r\nCREATE INDEX IF NOT EXISTS index_name ON table_name(column_name);\r\n```\r\n\r\n### Destructive Patterns (Warn User First)\r\n\r\nThese operations permanently delete data. Only use when the user explicitly requests removal.\r\n\r\n**Drop a column:**\r\n```sql\r\nALTER TABLE table_name DROP COLUMN IF EXISTS column_name;\r\n```\r\n\r\n**Drop a table:**\r\n```sql\r\nDROP TABLE IF EXISTS table_name CASCADE;\r\n```\r\n\r\nAlways warn the user: \"This will permanently delete data. Are you sure?\"\r\n\r\n**Rename a column (data loss risk):**\r\nRenaming requires DROP + ADD. Instead, recommend:\r\n1. Add new column with desired name\r\n2. Copy data: `UPDATE table SET new_col = old_col;`\r\n3. Drop old column only after confirming data is migrated\r\n\r\n### Schema.sql Section Ordering (MANDATORY)\r\n\r\nEvery schema.sql file MUST follow this exact section order:\r\n\r\n1. **ALL `CREATE TABLE IF NOT EXISTS` statements** — parent tables BEFORE child tables\r\n2. **`ALTER TABLE ADD COLUMN IF NOT EXISTS` statements** — for schema modifications\r\n3. **`SECURITY DEFINER` helper functions** — if multi-table FK chains exist\r\n4. **ALL `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` statements**\r\n5. **ALL policy statements** — using `DO $$ IF NOT EXISTS` pattern\r\n6. **ALL `CREATE INDEX IF NOT EXISTS` statements**\r\n7. **`NOTIFY pgrst, 'reload schema';`** — ALWAYS the last line\r\n\r\n### Post-Modification Checklist\r\n\r\nAfter modifying schema.sql, you MUST also update:\r\n\r\n- [ ] **TypeScript interfaces** — add/remove fields to match new columns\r\n- [ ] **`.select()` queries** — include new columns in select statements\r\n- [ ] **INSERT operations** — include new columns where they have user-provided values\r\n- [ ] **UI components** — add input fields or display elements for new data\r\n\r\n### Rules\r\n\r\n1. **ALWAYS read schema.sql before modifying** — never write from memory\r\n2. **NEVER rewrite schema.sql from scratch** — modify the existing file\r\n3. **NEVER remove existing CREATE TABLE, RLS, or policy statements** unless explicitly asked\r\n4. **Use IF NOT EXISTS / IF EXISTS** for all operations (idempotency)\r\n5. **ALWAYS end with `NOTIFY pgrst, 'reload schema';`**\r\n6. **Update TypeScript types and queries** to match schema changes\r\n7. **Preserve section ordering** — don't interleave tables with policies\r\n8. **Column names must be consistent** across schema.sql, TypeScript interfaces, and CRUD operations\r\n9. **If schema has 3+ tables with FKs, ensure SECURITY DEFINER helper exists** — when adding tables, check if the schema now has 3+ tables with foreign key chains. If so, add a SECURITY DEFINER helper function if one doesn't exist yet.",
  },
  "nextjs-patterns": {
    name: "nextjs-patterns",
    description: "Next.js 15+ patterns for fonts, layout.tsx, file creation order, and common imports. Use when creating layout files, loading fonts, or structuring app directory.",
    category: "shared",
    agents: ["all"],
    instructions: "## When to Use\r\n- Creating or modifying layout.tsx\r\n- Loading fonts with next/font/google\r\n- Setting up app directory structure\r\n- Determining file creation order for a new project\r\n- Using shadcn/ui components or cn utility\r\n\r\n## Instructions\r\n\r\n### Font Loading (CRITICAL)\r\n\r\n- **ALWAYS** load fonts via `next/font/google` in app/layout.tsx\r\n- **NEVER** use `@import url('https://fonts.googleapis.com/...')` in CSS\r\n- Font CSS variables (--font-display, --font-body) are set in globals.css :root\r\n- Use `font-display` and `font-body` classes, or `font-[family-name:var(--font-display)]`\r\n\r\n### Font Pairing Reference\r\n\r\n| Pairing | Display | Body |\r\n|---------|---------|------|\r\n| editorial | Playfair_Display | Source_Serif_4 |\r\n| brutalist | Space_Mono | Work_Sans |\r\n| playful | Fredoka | Nunito |\r\n| luxury | Cormorant_Garamond | Montserrat |\r\n| retro | Righteous | Poppins |\r\n| geometric | Outfit | Space_Grotesk |\r\n| humanist | Fraunces | Source_Sans_3 |\r\n| minimal | DM_Sans | DM_Sans |\r\n| bold | Bebas_Neue | Open_Sans |\r\n| elegant | Libre_Baskerville | Karla |\r\n\r\n### layout.tsx Template\r\n\r\n```tsx\r\nimport type { Metadata } from 'next'\r\nimport { Display_Font, Body_Font } from 'next/font/google'\r\nimport './globals.css'\r\n\r\nconst displayFont = Display_Font({ subsets: ['latin'], variable: '--font-display', weight: ['400', '700'] })\r\nconst bodyFont = Body_Font({ subsets: ['latin'], variable: '--font-body', weight: ['400', '600'] })\r\n\r\nexport const metadata: Metadata = { title: 'APP_NAME', description: 'APP_DESCRIPTION' }\r\n\r\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <html lang=\"en\" className={`${displayFont.variable} ${bodyFont.variable}`} suppressHydrationWarning>\r\n      <body className=\"min-h-screen bg-background font-body antialiased\" suppressHydrationWarning>\r\n        {children}\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\n```\r\n\r\n### File Creation Order (MANDATORY)\r\n\r\nWhen creating a new project, follow this exact order:\r\n\r\n1. **schema.sql** — Database schema (if architecture.md has DATABASE section). MUST be first.\r\n2. **app/globals.css** — CSS variables from DESIGN_DIRECTION\r\n3. **app/layout.tsx** — fonts from typography.pairing\r\n4. **lib/utils.ts** — cn() utility function (required by all UI components)\r\n5. **components/ui/*.tsx** — UI primitives (button, card, input, label, etc.). Only create files for components actually imported by your pages/components.\r\n6. **types/index.ts** — TypeScript types and interfaces (mirror schema.sql columns)\r\n7. **lib/supabase.ts** — Supabase client (if DATABASE section exists)\r\n8. **hooks/** — Custom hooks (e.g., useAuth.ts)\r\n9. **components/** — App-specific React components\r\n10. **app/page.tsx and ALL route pages** — Every route from architecture.md ROUTES section MUST have a corresponding `app/**/page.tsx` file\r\n\r\nThis order prevents import errors — each file only depends on files created before it.\r\n\r\n### Common Imports & Patterns\r\n\r\n**'use client' directive:**\r\n- Add `'use client'` at top of any component using hooks (useState, useEffect, etc.) or event handlers\r\n- Server components (no directive) can be async and fetch data directly\r\n- **NEVER combine 'use client' with async** — this crashes the app\r\n\r\n**shadcn/ui imports:**\r\n```tsx\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\"\r\nimport { Input } from \"@/components/ui/input\"\r\n```\r\n\r\n**cn utility:**\r\n```tsx\r\nimport { cn } from \"@/lib/utils\"\r\n\r\n// Usage: conditional classes\r\n<div className={cn(\"base-classes\", condition && \"conditional-class\")} />\r\n```\r\n\r\n**Hydration safety:**\r\n- Never put interactive elements (`<button>`, `<a>`) inside each other\r\n- This causes hydration mismatches\r\n\r\n### RULES CHECKLIST\r\n\r\nBefore completing any layout or app structure, verify:\r\n- [ ] Fonts loaded via `next/font/google`, not CSS @import url()\r\n- [ ] layout.tsx sets font CSS variables on `<html>` element\r\n- [ ] Files created in correct dependency order\r\n- [ ] All interactive components have `'use client'` directive\r\n- [ ] No `'use client'` + async combination\r\n- [ ] shadcn/ui imports use `@/components/ui/` path\r\n- [ ] No nested interactive elements (`<button>` inside `<a>` or vice versa)\r\n- [ ] lib/utils.ts created with cn() before any components/ui/ files\r\n- [ ] Every UI component imported in code has a corresponding components/ui/{name}.tsx file\r\n- [ ] Every route listed in architecture.md ROUTES has a corresponding app/**/page.tsx file",
  },
  "react-component": {
    name: "react-component",
    description: "Create React/Next.js components with TypeScript. Use when building UI components, defining interfaces, or organizing component files.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Creating new UI components\r\n- Defining TypeScript interfaces for props\r\n- Organizing component file structure\r\n- Deciding on component patterns\r\n\r\n## Instructions\r\n\r\n### Component Structure\r\n\r\n```tsx\r\n// components/FeatureCard.tsx\r\n'use client' // Required if using hooks or event handlers\r\n\r\nimport { useState } from 'react'\r\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'\r\n\r\ninterface FeatureCardProps {\r\n  title: string\r\n  description: string\r\n  icon?: React.ReactNode\r\n  onAction?: () => void\r\n}\r\n\r\nexport function FeatureCard({ title, description, icon, onAction }: FeatureCardProps) {\r\n  return (\r\n    <Card className=\"bg-card\">\r\n      <CardHeader>\r\n        {icon && <div className=\"mb-2\">{icon}</div>}\r\n        <CardTitle className=\"font-display text-foreground\">{title}</CardTitle>\r\n      </CardHeader>\r\n      <CardContent>\r\n        <p className=\"text-muted-foreground\">{description}</p>\r\n        {onAction && (\r\n          <button onClick={onAction} className=\"mt-4 text-primary\">\r\n            Learn More\r\n          </button>\r\n        )}\r\n      </CardContent>\r\n    </Card>\r\n  )\r\n}\r\n```\r\n\r\n### 'use client' Rules\r\n\r\n| Component Has | Needs 'use client' |\r\n|---------------|-------------------|\r\n| useState, useEffect, useRef | YES |\r\n| onClick, onChange, onSubmit | YES |\r\n| useContext with client state | YES |\r\n| Only props + JSX (no hooks) | NO |\r\n| async data fetching (server) | NO |\r\n\r\n```tsx\r\n// ❌ Client Component CANNOT be async\r\n'use client'\r\nexport default async function Page() { ... } // CRASHES!\r\n\r\n// ✅ Server Component CAN be async (no 'use client')\r\nexport default async function Page() {\r\n  const data = await fetchData()\r\n  return <div>{data}</div>\r\n}\r\n\r\n// ✅ Client Component with data fetching\r\n'use client'\r\nexport default function Page() {\r\n  const [data, setData] = useState(null)\r\n  useEffect(() => { fetchData().then(setData) }, [])\r\n  return <div>{data}</div>\r\n}\r\n```\r\n\r\n### TypeScript Interface Patterns\r\n\r\n```tsx\r\n// Always define explicit interfaces\r\ninterface Item {\r\n  id: string\r\n  name: string\r\n  status: \"todo\" | \"in-progress\" | \"done\"\r\n  createdAt: Date\r\n}\r\n\r\n// Props with optional fields and defaults\r\ninterface ListProps {\r\n  items?: Item[]\r\n  onSelect?: (item: Item) => void\r\n  className?: string\r\n}\r\n\r\n// Safe defaults for props\r\nfunction List({ items = [], onSelect, className }: ListProps) {\r\n  return (\r\n    <ul className={className}>\r\n      {items.map(item => (\r\n        <li key={item.id} onClick={() => onSelect?.(item)}>\r\n          {item.name}\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n```\r\n\r\n### File Creation Order (MANDATORY)\r\n\r\n1. **schema.sql** — Database schema (if architecture.md has DATABASE section)\r\n2. **app/globals.css** — CSS variables from DESIGN_DIRECTION\r\n3. **app/layout.tsx** — fonts from typography.pairing\r\n4. **types/index.ts** — shared TypeScript interfaces\r\n5. **lib/** — helper functions (supabase client, etc.)\r\n6. **components/** — reusable app-specific custom components\r\n7. **app/page.tsx and ALL routes** — every route from architecture.md ROUTES\r\n\r\n> **PRE-INSTALLED (DO NOT CREATE):** lib/utils.ts and components/ui/*.tsx are pre-installed by shadcn. Just import them.\r\n\r\n### Named Exports Pattern\r\n\r\n```tsx\r\n// ✅ PREFERRED - named exports\r\nexport function Button() { ... }\r\nexport function Card() { ... }\r\n\r\n// Usage:\r\nimport { Button, Card } from '@/components/ui'\r\n\r\n// Default export for pages only\r\nexport default function HomePage() { ... }\r\n```\r\n\r\n### Section Component Pattern (Blueprint-Driven)\r\n\r\n```tsx\r\n// components/HeroSection.tsx\r\n'use client'\r\n\r\ninterface HeroSectionProps {\r\n  headline: string\r\n  subheadline: string\r\n  ctaText: string\r\n  ctaHref: string\r\n}\r\n\r\nexport function HeroSection({ headline, subheadline, ctaText, ctaHref }: HeroSectionProps) {\r\n  return (\r\n    <section className=\"min-h-[80vh] flex flex-col items-center justify-center text-center px-4 bg-background\">\r\n      <h1 className=\"font-display text-5xl md:text-7xl font-bold text-foreground mb-6\">\r\n        {headline}\r\n      </h1>\r\n      <p className=\"text-xl text-muted-foreground max-w-2xl mb-8\">\r\n        {subheadline}\r\n      </p>\r\n      <a\r\n        href={ctaHref}\r\n        className=\"px-8 py-4 bg-primary text-white rounded-xl font-semibold shadow-lg hover:shadow-xl hover:scale-105 transition-all duration-200\"\r\n      >\r\n        {ctaText}\r\n      </a>\r\n    </section>\r\n  )\r\n}\r\n```\r\n\r\n### Page Composition Pattern\r\n\r\n```tsx\r\n// app/page.tsx\r\nimport { HeroSection } from '@/components/HeroSection'\r\nimport { FeaturesGrid } from '@/components/FeaturesGrid'\r\n\r\n// Deterministic mock data - NEVER empty arrays!\r\nconst HERO_DATA = {\r\n  headline: 'Ship Faster',\r\n  subheadline: 'The tool that gets out of your way.',\r\n  ctaText: 'Start Free',\r\n  ctaHref: '#pricing'\r\n}\r\n\r\nconst FEATURES_DATA = {\r\n  title: 'Features',\r\n  features: [\r\n    { id: '1', title: 'Fast', description: 'Blazing fast performance' },\r\n    { id: '2', title: 'Simple', description: 'Easy to use interface' },\r\n    { id: '3', title: 'Secure', description: 'Enterprise-grade security' },\r\n  ]\r\n}\r\n\r\nexport default function Home() {\r\n  return (\r\n    <div className=\"min-h-screen bg-background\">\r\n      <HeroSection {...HERO_DATA} />\r\n      <FeaturesGrid {...FEATURES_DATA} />\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### RULES CHECKLIST\r\n\r\n- [ ] 'use client' added if using hooks/events\r\n- [ ] TypeScript interfaces defined for all props\r\n- [ ] Safe defaults for optional array props (`items = []`)\r\n- [ ] All arrays have unique `key` props when mapping\r\n- [ ] Tailwind theme classes used for colors (bg-primary, text-foreground, etc. — no hardcoded hex)\r\n- [ ] font-display for headings, font-body for text\r\n- [ ] Mock data initialized (NEVER empty arrays in useState)\r\n- [ ] Every route in architecture.md ROUTES section has a corresponding app/**/page.tsx\r\n- [ ] components/ui/ files are pre-installed — do NOT create them, just import",
  },
  "responsive-design": {
    name: "responsive-design",
    description: "Build mobile-first responsive layouts with Tailwind breakpoints. Use when creating responsive grids, typography, or adaptive components.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Creating responsive page layouts\r\n- Adapting components for different screen sizes\r\n- Building mobile-first designs\r\n- Using Tailwind breakpoints\r\n\r\n## Instructions\r\n\r\n### Mobile-First Approach\r\n\r\nAlways start with mobile styles, then add breakpoints for larger screens:\r\n\r\n```tsx\r\n// ❌ WRONG - desktop-first (harder to maintain)\r\n<div className=\"flex-row md:flex-col\">\r\n\r\n// ✅ CORRECT - mobile-first\r\n<div className=\"flex-col md:flex-row\">\r\n```\r\n\r\n### Tailwind Breakpoint Reference\r\n\r\n| Prefix | Min Width | Target |\r\n|--------|-----------|--------|\r\n| (none) | 0px | Mobile phones |\r\n| `sm:` | 640px | Large phones, small tablets |\r\n| `md:` | 768px | Tablets |\r\n| `lg:` | 1024px | Laptops |\r\n| `xl:` | 1280px | Desktops |\r\n| `2xl:` | 1536px | Large screens |\r\n\r\n### Responsive Grid Patterns\r\n\r\n```tsx\r\n// 1 column mobile → 2 columns tablet → 3 columns desktop\r\n<div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\r\n  {items.map(item => <Card key={item.id} {...item} />)}\r\n</div>\r\n\r\n// 1 column mobile → 2 columns tablet → 4 columns desktop\r\n<div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4\">\r\n  {stats.map(stat => <StatCard key={stat.id} {...stat} />)}\r\n</div>\r\n\r\n// Auto-fill with minimum width (flexible)\r\n<div className=\"grid grid-cols-[repeat(auto-fill,minmax(280px,1fr))] gap-6\">\r\n  {cards.map(card => <Card key={card.id} {...card} />)}\r\n</div>\r\n```\r\n\r\n### Responsive Typography\r\n\r\n```tsx\r\n// Headline: small on mobile, large on desktop\r\n<h1 className=\"text-3xl md:text-5xl lg:text-7xl font-display font-bold text-foreground\">\r\n  Welcome\r\n</h1>\r\n\r\n// Subheadline: responsive sizing\r\n<p className=\"text-lg md:text-xl lg:text-2xl text-muted-foreground\">\r\n  Subtitle text here\r\n</p>\r\n\r\n// Body text with responsive line length\r\n<p className=\"text-base md:text-lg max-w-prose\">\r\n  Body text content...\r\n</p>\r\n```\r\n\r\n### Responsive Spacing\r\n\r\n```tsx\r\n// Padding: tighter on mobile, looser on desktop\r\n<section className=\"py-12 md:py-20 lg:py-24 px-4 md:px-8\">\r\n\r\n// Gap: smaller on mobile\r\n<div className=\"flex flex-col md:flex-row gap-4 md:gap-8\">\r\n\r\n// Container with responsive padding\r\n<div className=\"container mx-auto px-4 md:px-6 lg:px-8\">\r\n```\r\n\r\n### Show/Hide Patterns\r\n\r\n```tsx\r\n// Hide on mobile, show on desktop\r\n<nav className=\"hidden md:flex gap-6\">\r\n\r\n// Show on mobile, hide on desktop\r\n<button className=\"md:hidden\">Menu</button>\r\n\r\n// Different content per breakpoint\r\n<span className=\"md:hidden\">Mobile Label</span>\r\n<span className=\"hidden md:inline\">Desktop Label with More Detail</span>\r\n```\r\n\r\n### Responsive Hero Section\r\n\r\n```tsx\r\n<section className=\"min-h-[60vh] md:min-h-[80vh] flex flex-col items-center justify-center text-center px-4 md:px-8\">\r\n  <h1 className=\"font-display text-4xl md:text-6xl lg:text-7xl font-bold text-foreground mb-4 md:mb-6\">\r\n    Ship Faster\r\n  </h1>\r\n  <p className=\"text-lg md:text-xl text-muted-foreground max-w-xl md:max-w-2xl mb-6 md:mb-8\">\r\n    The tool that gets out of your way and helps you build better products.\r\n  </p>\r\n  <div className=\"flex flex-col sm:flex-row gap-3 md:gap-4\">\r\n    <Button className=\"w-full sm:w-auto\">Get Started</Button>\r\n    <Button variant=\"outline\" className=\"w-full sm:w-auto\">Learn More</Button>\r\n  </div>\r\n</section>\r\n```\r\n\r\n### Responsive Navigation\r\n\r\n```tsx\r\n// Mobile: hamburger menu, Desktop: horizontal nav\r\n<header className=\"flex items-center justify-between px-4 py-4\">\r\n  <Logo />\r\n\r\n  {/* Desktop nav */}\r\n  <nav className=\"hidden md:flex items-center gap-6\">\r\n    <a href=\"#features\">Features</a>\r\n    <a href=\"#pricing\">Pricing</a>\r\n    <Button>Sign Up</Button>\r\n  </nav>\r\n\r\n  {/* Mobile menu button */}\r\n  <button className=\"md:hidden\">\r\n    <Menu className=\"h-6 w-6\" />\r\n  </button>\r\n</header>\r\n```\r\n\r\n### Responsive Card Layout\r\n\r\n```tsx\r\n// Card with stacked layout on mobile, horizontal on desktop\r\n<div className=\"flex flex-col md:flex-row bg-card rounded-xl overflow-hidden\">\r\n  <div className=\"md:w-1/3\">\r\n    <img src={image} className=\"w-full h-48 md:h-full object-cover\" />\r\n  </div>\r\n  <div className=\"p-4 md:p-6 md:w-2/3\">\r\n    <h3 className=\"text-xl md:text-2xl font-display\">{title}</h3>\r\n    <p className=\"mt-2 text-muted-foreground\">{description}</p>\r\n  </div>\r\n</div>\r\n```\r\n\r\n### Common Responsive Patterns\r\n\r\n| Pattern | Classes |\r\n|---------|---------|\r\n| Stack → Row | `flex flex-col md:flex-row` |\r\n| Full width → Centered | `w-full md:max-w-xl md:mx-auto` |\r\n| Single → Multi column | `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3` |\r\n| Hidden → Visible | `hidden md:block` |\r\n| Visible → Hidden | `block md:hidden` |\r\n| Small text → Large | `text-sm md:text-base lg:text-lg` |\r\n| Tight padding → Loose | `p-4 md:p-6 lg:p-8` |\r\n\r\n### Testing Responsive Designs\r\n\r\n1. Start with mobile view (375px width)\r\n2. Test at each breakpoint: 640px, 768px, 1024px, 1280px\r\n3. Ensure no horizontal scroll\r\n4. Verify touch targets are 44px+ on mobile\r\n5. Check text readability at all sizes\r\n\r\n### RULES\r\n\r\n1. **Mobile-first always** — base styles for mobile, breakpoints for larger\r\n2. **Use semantic breakpoints** — sm for phones, md for tablets, lg for desktop\r\n3. **Don't hide essential content** — adapt layout, don't remove information\r\n4. **Test all breakpoints** — verify layout at each size\r\n5. **Keep touch targets large** — minimum 44x44px for interactive elements\r\n6. **Use flexible units** — prefer % and rem over fixed px",
  },
  "rls-policies": {
    name: "rls-policies",
    description: "Create Supabase schema.sql with Row Level Security policies. Use when setting up database security with IF NOT EXISTS patterns.",
    category: "supabase",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Creating schema.sql for Supabase\r\n- Setting up Row Level Security (RLS)\r\n- Defining table policies\r\n- Architecture.md has DATABASE section\r\n\r\n### Choose the Right RLS Pattern\r\n\r\n| Schema Type | Example | Pattern to Use |\r\n|-------------|---------|----------------|\r\n| Single table, no auth | Todo list | Pattern 1 (public) or 5 (public CRUD) |\r\n| Single table, with auth | Personal notes | Pattern 4 or 7 (user-owned rows) |\r\n| Content with drafts | Blog | Pattern 6 (draft/publish) |\r\n| Multi-table with teams/orgs | Project management, SaaS | **Pattern 8 (SECURITY DEFINER) — MANDATORY** |\r\n\r\n**If your schema has 3+ tables with foreign key chains** (e.g., workspaces → projects → issues), you **MUST** use Pattern 8 with a `SECURITY DEFINER` helper function. Direct cross-table subqueries in policies WILL cause `relation does not exist` errors or infinite recursion.\r\n\r\n> **⚠️ CRITICAL WARNING — Auth Detection:**\r\n> If the DATABASE specification has NO `user_id` columns referencing `auth.users`, NO `profiles` table, and NO `auth.users` foreign keys, this is a **non-auth app**. You MUST use **Pattern 5 (Public CRUD)** for ALL tables. NEVER use `auth.uid()` in policies for non-auth apps — the client connects with the anon key, `auth.uid()` returns NULL, and ALL INSERT/UPDATE/DELETE operations will silently fail with \"new row violates row-level security policy\". This is the #1 cause of RLS-blocked writes in generated apps.\r\n\r\n### Supabase Official Policy Guidelines\r\n\r\nThese patterns come from Supabase's official AI prompt for RLS policy generation:\r\n\r\n**PERMISSIVE vs RESTRICTIVE:**\r\n- Always use PERMISSIVE policies (the default). Multiple PERMISSIVE policies on a table combine with OR — a row is accessible if ANY policy allows it.\r\n- Avoid RESTRICTIVE policies unless you have a specific security requirement. RESTRICTIVE policies combine with AND — ALL must pass, which causes unexpected access denials.\r\n\r\n**Syntax Ordering (MANDATORY):**\r\n```sql\r\n-- CORRECT: FOR before TO\r\ncreate policy \"Policy name\" on table_name\r\n  for select\r\n  to authenticated\r\n  using ( ... );\r\n\r\n-- INCORRECT: TO before FOR\r\ncreate policy \"Policy name\" on table_name\r\n  to authenticated\r\n  for select\r\n  using ( ... );\r\n```\r\n\r\n**Operation-Specific Clauses:**\r\n| Operation | USING | WITH CHECK | Notes |\r\n|-----------|-------|------------|-------|\r\n| SELECT | Required | Never | Filter which rows are visible |\r\n| INSERT | Never | Required | Validate new row data |\r\n| UPDATE | Required (filter rows) | Required (validate new data) | Both needed |\r\n| DELETE | Required | Never | Filter which rows can be deleted |\r\n\r\n**Minimize Joins in Policies:**\r\nInstead of joining the source table to the target table in a policy, fetch relevant IDs into a set and use IN:\r\n\r\n```sql\r\n-- BAD: join in policy (slow)\r\ncreate policy \"Team access\" on projects\r\n  for select to authenticated\r\n  using (\r\n    (select auth.uid()) in (\r\n      select user_id from team_members\r\n      where team_members.team_id = projects.team_id\r\n    )\r\n  );\r\n\r\n-- GOOD: fetch IDs, then use IN (fast)\r\ncreate policy \"Team access\" on projects\r\n  for select to authenticated\r\n  using (\r\n    team_id in (\r\n      select team_id from team_members\r\n      where user_id = (select auth.uid())\r\n    )\r\n  );\r\n```\r\n\r\n**Index Columns Used in Policies:**\r\nAdd indexes on any columns referenced in RLS policy USING/WITH CHECK clauses:\r\n\r\n```sql\r\n-- After all policies, add indexes for RLS performance\r\ncreate index if not exists idx_projects_team_id on projects(team_id);\r\ncreate index if not exists idx_team_members_user_id on team_members(user_id);\r\ncreate index if not exists idx_issues_project_id on issues(project_id);\r\n```\r\n\r\n## Instructions\r\n\r\n### CRITICAL — schema.sql is a MANDATORY File\r\n\r\n⚠️ **schema.sql is NOT optional documentation — it is a MANDATORY file that MUST be created in the project root.**\r\n\r\nThe auto-execution pipeline reads `schema.sql` from the project root and executes it against Supabase. Without this file, NO tables will be created and ALL database operations will fail.\r\n\r\n- EVERY table listed in architecture.md DATABASE section MUST have a corresponding `CREATE TABLE IF NOT EXISTS` statement in schema.sql.\r\n- Create this file BEFORE any component files.\r\n\r\n### Schema.sql Section Ordering (MANDATORY)\r\n\r\nEvery schema.sql file MUST follow this exact section order:\r\n\r\n1. **ALL `CREATE TABLE IF NOT EXISTS` statements** — parent tables BEFORE child tables (e.g., `workspaces` before `workspace_members` before `projects` before `issues`)\r\n2. **`SECURITY DEFINER` helper functions** — if the schema has multi-table foreign key chains. Create AFTER all tables exist.\r\n3. **ALL `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` statements**\r\n4. **ALL policy statements** — using `DO $$ IF NOT EXISTS` pattern (NEVER bare `CREATE POLICY`)\r\n5. **ALL `CREATE INDEX IF NOT EXISTS` statements**\r\n6. **`NOTIFY pgrst, 'reload schema';`** — ALWAYS the last line of schema.sql\r\n\r\n⚠️ **NEVER interleave** table creation with policies. ALL tables must exist before ANY policy is created. Policies that subquery other tables will fail with `relation \"tablename\" does not exist` if the referenced table hasn't been created yet.\r\n\r\n⚠️ **NEVER use `DROP POLICY IF EXISTS` + bare `CREATE POLICY`** — always use the `DO $$ IF NOT EXISTS` pattern from the template below.\r\n\r\n### schema.sql Template\r\n\r\nALWAYS create this as a real file named `schema.sql` in the project root. Use IF NOT EXISTS patterns for idempotency:\r\n\r\n```sql\r\n-- schema.sql\r\n-- Run this in Supabase SQL Editor to set up your database\r\n\r\n-- Create table with IF NOT EXISTS\r\nCREATE TABLE IF NOT EXISTS todos (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  created_at timestamptz DEFAULT now(),\r\n  text text NOT NULL,\r\n  completed boolean DEFAULT false\r\n);\r\n\r\n-- Enable Row Level Security\r\nALTER TABLE todos ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Create policy with DO $$ block (prevents errors if policy exists)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Allow public access'\r\n  ) THEN\r\n    CREATE POLICY \"Allow public access\" ON todos\r\n      FOR ALL\r\n      USING (true)\r\n      WITH CHECK (true);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Reload PostgREST schema cache to detect new tables immediately\r\nNOTIFY pgrst, 'reload schema';\r\n```\r\n\r\n### Common Table Patterns\r\n\r\n**Basic table with timestamps:**\r\n\r\n```sql\r\nCREATE TABLE IF NOT EXISTS posts (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  created_at timestamptz DEFAULT now(),\r\n  updated_at timestamptz DEFAULT now(),\r\n  title text NOT NULL,\r\n  content text,\r\n  published boolean DEFAULT false\r\n);\r\n```\r\n\r\n**Table with user reference (for auth):**\r\n\r\n```sql\r\nCREATE TABLE IF NOT EXISTS user_profiles (\r\n  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\r\n  created_at timestamptz DEFAULT now(),\r\n  username text UNIQUE NOT NULL,\r\n  avatar_url text,\r\n  bio text\r\n);\r\n```\r\n\r\n**Table with foreign key:**\r\n\r\n```sql\r\nCREATE TABLE IF NOT EXISTS comments (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  created_at timestamptz DEFAULT now(),\r\n  post_id uuid REFERENCES posts(id) ON DELETE CASCADE,\r\n  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,\r\n  content text NOT NULL\r\n);\r\n```\r\n\r\n### RLS Policy Patterns\r\n\r\n**1. Public access (anyone can read/write):**\r\n\r\n```sql\r\nALTER TABLE todos ENABLE ROW LEVEL SECURITY;\r\n\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Allow public access'\r\n  ) THEN\r\n    CREATE POLICY \"Allow public access\" ON todos\r\n      FOR ALL\r\n      USING (true)\r\n      WITH CHECK (true);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**2. Read-only public access:**\r\n\r\n```sql\r\nALTER TABLE posts ENABLE ROW LEVEL SECURITY;\r\n\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Anyone can view published posts'\r\n  ) THEN\r\n    CREATE POLICY \"Anyone can view published posts\" ON posts\r\n      FOR SELECT\r\n      USING (published = true);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**3. User-specific access (authenticated users own their data):**\r\n\r\n> **Performance note:** Always wrap `auth.uid()` in `(select ...)` — e.g., `(select auth.uid())`. This lets Postgres cache the value per-statement instead of re-evaluating per-row, giving ~95% performance improvement on large tables.\r\n\r\n```sql\r\nALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Users can view all profiles\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'user_profiles' AND policyname = 'Profiles are viewable by everyone'\r\n  ) THEN\r\n    CREATE POLICY \"Profiles are viewable by everyone\" ON user_profiles\r\n      FOR SELECT\r\n      USING (true);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can only update their own profile\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'user_profiles' AND policyname = 'Users can update own profile'\r\n  ) THEN\r\n    CREATE POLICY \"Users can update own profile\" ON user_profiles\r\n      FOR UPDATE\r\n      USING ((select auth.uid()) = id)\r\n      WITH CHECK ((select auth.uid()) = id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can only insert their own profile\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'user_profiles' AND policyname = 'Users can insert own profile'\r\n  ) THEN\r\n    CREATE POLICY \"Users can insert own profile\" ON user_profiles\r\n      FOR INSERT\r\n      WITH CHECK ((select auth.uid()) = id);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**4. User owns their rows:**\r\n\r\n```sql\r\nALTER TABLE todos ENABLE ROW LEVEL SECURITY;\r\n\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can manage own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can manage own todos\" ON todos\r\n      FOR ALL\r\n      USING ((select auth.uid()) = user_id)\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**5. Public CRUD (no auth required) — DEFAULT for non-auth apps:**\r\n\r\nFor apps without authentication (todo lists, trackers, simple tools). This is the DEFAULT pattern when the DATABASE specification has no auth.users references. Uses explicit per-operation policies with `TO anon, authenticated`:\r\n\r\n```sql\r\nALTER TABLE todos ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Anyone can view todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Allow public select'\r\n  ) THEN\r\n    CREATE POLICY \"Allow public select\" ON todos\r\n      FOR SELECT\r\n      TO anon, authenticated\r\n      USING (true);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Anyone can create todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Allow public insert'\r\n  ) THEN\r\n    CREATE POLICY \"Allow public insert\" ON todos\r\n      FOR INSERT\r\n      TO anon, authenticated\r\n      WITH CHECK (true);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Anyone can update todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Allow public update'\r\n  ) THEN\r\n    CREATE POLICY \"Allow public update\" ON todos\r\n      FOR UPDATE\r\n      TO anon, authenticated\r\n      USING (true)\r\n      WITH CHECK (true);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Anyone can delete todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Allow public delete'\r\n  ) THEN\r\n    CREATE POLICY \"Allow public delete\" ON todos\r\n      FOR DELETE\r\n      TO anon, authenticated\r\n      USING (true);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**6. Content with Draft/Publish:**\r\n\r\nFor content apps where the public sees published items, but authors can see their own drafts. The two SELECT policies combine with OR — a row is visible if EITHER policy matches.\r\n\r\n```sql\r\nALTER TABLE posts ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Public can view published content\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Anyone can view published posts'\r\n  ) THEN\r\n    CREATE POLICY \"Anyone can view published posts\" ON posts\r\n      FOR SELECT\r\n      TO anon, authenticated\r\n      USING (published = true);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authors can view their own posts (including drafts)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Authors can view own posts'\r\n  ) THEN\r\n    CREATE POLICY \"Authors can view own posts\" ON posts\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authors can create posts\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Authors can create posts'\r\n  ) THEN\r\n    CREATE POLICY \"Authors can create posts\" ON posts\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authors can update their own posts\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Authors can update own posts'\r\n  ) THEN\r\n    CREATE POLICY \"Authors can update own posts\" ON posts\r\n      FOR UPDATE\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id)\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authors can delete their own posts\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Authors can delete own posts'\r\n  ) THEN\r\n    CREATE POLICY \"Authors can delete own posts\" ON posts\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n> **Key insight:** Multiple SELECT policies on the same table combine with OR semantics. A row is visible if ANY SELECT policy's `USING` clause evaluates to true. This is how draft/publish works — public sees `published = true` rows, while the author also sees their own unpublished rows via `(select auth.uid()) = user_id`.\r\n\r\n**7. User-Owned Rows with Complete CRUD:**\r\n\r\nFor authenticated apps where users own their rows. Explicit per-operation policies with `TO authenticated` role:\r\n\r\n```sql\r\nALTER TABLE todos ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Users can view their own todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can view own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can view own todos\" ON todos\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can create their own todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can create own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can create own todos\" ON todos\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can update their own todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can update own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can update own todos\" ON todos\r\n      FOR UPDATE\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id)\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can delete their own todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can delete own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can delete own todos\" ON todos\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**8. Team/Workspace Access (Multi-Table):**\r\n\r\nUse this pattern for workspaces, teams, organizations, or any multi-tenant app where access depends on membership in a parent entity. The key challenge is avoiding **infinite recursion** — when policies on table A query table B, and table B's policies query table A, PostgreSQL enters an infinite loop.\r\n\r\n**Step 1: Create a SECURITY DEFINER helper function**\r\n\r\nThis function bypasses RLS (runs as the function owner, not the calling user), breaking the circular dependency chain. All policies reference this function instead of querying membership tables directly.\r\n\r\n```sql\r\n-- SECURITY DEFINER helper: returns workspace IDs accessible to current user\r\n-- Bypasses RLS to prevent circular dependency between workspaces ↔ members\r\nCREATE OR REPLACE FUNCTION get_user_workspace_ids()\r\nRETURNS SETOF uuid\r\nLANGUAGE sql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\n  SELECT id FROM workspaces WHERE owner_id = (select auth.uid())\r\n  UNION\r\n  SELECT workspace_id FROM workspace_members WHERE user_id = (select auth.uid());\r\n$$;\r\n```\r\n\r\n> **Why SECURITY DEFINER?** This function runs with the permissions of its owner (typically the superuser who created it), bypassing RLS on the tables it queries. `SET search_path = public` prevents search_path hijacking attacks — always include this with SECURITY DEFINER functions.\r\n\r\n**Step 2: Parent table policies (workspaces)**\r\n\r\n```sql\r\nALTER TABLE workspaces ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Members can view workspaces they belong to (uses helper to avoid recursion)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'workspaces' AND policyname = 'Members can view workspaces'\r\n  ) THEN\r\n    CREATE POLICY \"Members can view workspaces\" ON workspaces\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING (id IN (SELECT get_user_workspace_ids()));\r\n  END IF;\r\nEND $$;\r\n\r\n-- Only owners can update their workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'workspaces' AND policyname = 'Owners can update workspaces'\r\n  ) THEN\r\n    CREATE POLICY \"Owners can update workspaces\" ON workspaces\r\n      FOR UPDATE\r\n      TO authenticated\r\n      USING (owner_id = (select auth.uid()))\r\n      WITH CHECK (owner_id = (select auth.uid()));\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authenticated users can create workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'workspaces' AND policyname = 'Users can create workspaces'\r\n  ) THEN\r\n    CREATE POLICY \"Users can create workspaces\" ON workspaces\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK (owner_id = (select auth.uid()));\r\n  END IF;\r\nEND $$;\r\n\r\n-- Only owners can delete their workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'workspaces' AND policyname = 'Owners can delete workspaces'\r\n  ) THEN\r\n    CREATE POLICY \"Owners can delete workspaces\" ON workspaces\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING (owner_id = (select auth.uid()));\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**Step 3: Membership table policies (workspace_members)**\r\n\r\n```sql\r\nALTER TABLE workspace_members ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Members can see other members in their workspaces (uses helper)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'workspace_members' AND policyname = 'Members can view workspace members'\r\n  ) THEN\r\n    CREATE POLICY \"Members can view workspace members\" ON workspace_members\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING (workspace_id IN (SELECT get_user_workspace_ids()));\r\n  END IF;\r\nEND $$;\r\n\r\n-- Workspace owners can add members (uses helper)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'workspace_members' AND policyname = 'Owners can add members'\r\n  ) THEN\r\n    CREATE POLICY \"Owners can add members\" ON workspace_members\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK (\r\n        workspace_id IN (\r\n          SELECT id FROM workspaces WHERE owner_id = (select auth.uid())\r\n        )\r\n      );\r\n  END IF;\r\nEND $$;\r\n\r\n-- Members can remove themselves; owners can remove anyone\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'workspace_members' AND policyname = 'Members can leave or owners can remove'\r\n  ) THEN\r\n    CREATE POLICY \"Members can leave or owners can remove\" ON workspace_members\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING (\r\n        user_id = (select auth.uid())\r\n        OR workspace_id IN (\r\n          SELECT id FROM workspaces WHERE owner_id = (select auth.uid())\r\n        )\r\n      );\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**Step 4: Child table policies (projects, issues, etc.)**\r\n\r\nChild tables reference the helper function through their parent's workspace_id:\r\n\r\n```sql\r\nALTER TABLE projects ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Members can view projects in their workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'projects' AND policyname = 'Members can view projects'\r\n  ) THEN\r\n    CREATE POLICY \"Members can view projects\" ON projects\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING (workspace_id IN (SELECT get_user_workspace_ids()));\r\n  END IF;\r\nEND $$;\r\n\r\n-- Members can create projects in their workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'projects' AND policyname = 'Members can create projects'\r\n  ) THEN\r\n    CREATE POLICY \"Members can create projects\" ON projects\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK (workspace_id IN (SELECT get_user_workspace_ids()));\r\n  END IF;\r\nEND $$;\r\n\r\n-- Members can update projects in their workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'projects' AND policyname = 'Members can update projects'\r\n  ) THEN\r\n    CREATE POLICY \"Members can update projects\" ON projects\r\n      FOR UPDATE\r\n      TO authenticated\r\n      USING (workspace_id IN (SELECT get_user_workspace_ids()))\r\n      WITH CHECK (workspace_id IN (SELECT get_user_workspace_ids()));\r\n  END IF;\r\nEND $$;\r\n\r\n-- Members can delete projects in their workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'projects' AND policyname = 'Members can delete projects'\r\n  ) THEN\r\n    CREATE POLICY \"Members can delete projects\" ON projects\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING (workspace_id IN (SELECT get_user_workspace_ids()));\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n**Step 5: Deep child tables (comments on issues)**\r\n\r\nFor tables further down the hierarchy, cascade through parent tables using JOINs — but still use the helper for the workspace check:\r\n\r\n```sql\r\nALTER TABLE comments ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Members can view comments on issues in their workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'comments' AND policyname = 'Members can view comments'\r\n  ) THEN\r\n    CREATE POLICY \"Members can view comments\" ON comments\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING (\r\n        issue_id IN (\r\n          SELECT i.id FROM issues i\r\n          JOIN projects p ON p.id = i.project_id\r\n          WHERE p.workspace_id IN (SELECT get_user_workspace_ids())\r\n        )\r\n      );\r\n  END IF;\r\nEND $$;\r\n\r\n-- Members can create comments on issues in their workspaces\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'comments' AND policyname = 'Members can create comments'\r\n  ) THEN\r\n    CREATE POLICY \"Members can create comments\" ON comments\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK (\r\n        (select auth.uid()) = user_id\r\n        AND issue_id IN (\r\n          SELECT i.id FROM issues i\r\n          JOIN projects p ON p.id = i.project_id\r\n          WHERE p.workspace_id IN (SELECT get_user_workspace_ids())\r\n        )\r\n      );\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can update their own comments\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'comments' AND policyname = 'Users can update own comments'\r\n  ) THEN\r\n    CREATE POLICY \"Users can update own comments\" ON comments\r\n      FOR UPDATE\r\n      TO authenticated\r\n      USING (user_id = (select auth.uid()))\r\n      WITH CHECK (user_id = (select auth.uid()));\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can delete their own comments\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'comments' AND policyname = 'Users can delete own comments'\r\n  ) THEN\r\n    CREATE POLICY \"Users can delete own comments\" ON comments\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING (user_id = (select auth.uid()));\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n> **Adapt table/column names** to match your architecture.md. The pattern is: always use the `get_user_workspace_ids()` helper for workspace membership checks, never inline cross-table subqueries that would trigger RLS on other tables.\r\n\r\n### Full Example: Todo App with Auth\r\n\r\n```sql\r\n-- schema.sql for authenticated todo app\r\n\r\n-- Todos table\r\nCREATE TABLE IF NOT EXISTS todos (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  created_at timestamptz DEFAULT now(),\r\n  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\r\n  text text NOT NULL,\r\n  completed boolean DEFAULT false\r\n);\r\n\r\n-- Enable RLS\r\nALTER TABLE todos ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Users can only see their own todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can view own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can view own todos\" ON todos\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can create their own todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can create own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can create own todos\" ON todos\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can update their own todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can update own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can update own todos\" ON todos\r\n      FOR UPDATE\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id)\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Users can delete their own todos\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'todos' AND policyname = 'Users can delete own todos'\r\n  ) THEN\r\n    CREATE POLICY \"Users can delete own todos\" ON todos\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n```\r\n\r\n### Index Creation (Optional)\r\n\r\n```sql\r\n-- Create indexes for common queries\r\nCREATE INDEX IF NOT EXISTS todos_user_id_idx ON todos(user_id);\r\nCREATE INDEX IF NOT EXISTS todos_created_at_idx ON todos(created_at DESC);\r\n```\r\n\r\n### Full Example: Blog App with Draft/Publish\r\n\r\n```sql\r\n-- schema.sql for blog app with draft/publish workflow\r\n\r\n-- Posts table\r\nCREATE TABLE IF NOT EXISTS posts (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  created_at timestamptz DEFAULT now(),\r\n  updated_at timestamptz DEFAULT now(),\r\n  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\r\n  title text NOT NULL,\r\n  slug text UNIQUE NOT NULL,\r\n  content text,\r\n  excerpt text,\r\n  published boolean DEFAULT false\r\n);\r\n\r\n-- Enable RLS\r\nALTER TABLE posts ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Public can view published posts\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Anyone can view published posts'\r\n  ) THEN\r\n    CREATE POLICY \"Anyone can view published posts\" ON posts\r\n      FOR SELECT\r\n      TO anon, authenticated\r\n      USING (published = true);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authors can view their own posts (including drafts)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Authors can view own posts'\r\n  ) THEN\r\n    CREATE POLICY \"Authors can view own posts\" ON posts\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authors can create posts\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Authors can create posts'\r\n  ) THEN\r\n    CREATE POLICY \"Authors can create posts\" ON posts\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authors can update their own posts\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Authors can update own posts'\r\n  ) THEN\r\n    CREATE POLICY \"Authors can update own posts\" ON posts\r\n      FOR UPDATE\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id)\r\n      WITH CHECK ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Authors can delete their own posts\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE tablename = 'posts' AND policyname = 'Authors can delete own posts'\r\n  ) THEN\r\n    CREATE POLICY \"Authors can delete own posts\" ON posts\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING ((select auth.uid()) = user_id);\r\n  END IF;\r\nEND $$;\r\n\r\n-- Indexes\r\nCREATE INDEX IF NOT EXISTS posts_user_id_idx ON posts(user_id);\r\nCREATE INDEX IF NOT EXISTS posts_slug_idx ON posts(slug);\r\nCREATE INDEX IF NOT EXISTS posts_published_created_at_idx ON posts(published, created_at DESC);\r\n```\r\n\r\n### Validation Checklist\r\n\r\nAfter writing schema.sql, verify:\r\n\r\n- [ ] Every table from architecture.md DATABASE section has a CREATE TABLE statement\r\n- [ ] Every column from DATABASE section is present with matching name and type\r\n- [ ] RLS is enabled on every table\r\n- [ ] At least one policy exists per table\r\n- [ ] All IF NOT EXISTS and DO $$ patterns are used correctly\r\n- [ ] Every table with a `published` column has a draft-visibility SELECT policy for the author\r\n- [ ] Every table has a DELETE policy (not just SELECT+INSERT+UPDATE)\r\n- [ ] `auth.uid()` is wrapped in `(select ...)` for performance\r\n- [ ] No circular cross-table references in policies (use SECURITY DEFINER helpers)\r\n- [ ] If no auth.users references in DATABASE spec, ALL policies use USING(true)/WITH CHECK(true) (Pattern 5) — no auth.uid() anywhere\r\n- [ ] If auth is used, policies with auth.uid() checks are only on tables that have user_id FK columns\r\n\r\n### RULES\r\n\r\n1. **Always use IF NOT EXISTS** for tables and indexes\r\n2. **Always use DO $$ block** for policies (prevents duplicate errors)\r\n3. **Always enable RLS** with `ALTER TABLE ... ENABLE ROW LEVEL SECURITY`\r\n4. **Match columns to DATABASE section** in architecture.md\r\n5. **Use `(select auth.uid())`** for user-specific policies — always wrap in `(select ...)` for performance\r\n6. **Policy names must be unique** per table\r\n7. **schema.sql MUST be created as a real file in the project root** — it is NOT optional\r\n8. **Every table in architecture.md DATABASE section MUST have a CREATE TABLE in schema.sql**\r\n9. **Always include a DELETE policy** for every table — apps with delete buttons will fail silently without one\r\n10. **For tables with a `published` column**, always add an author-can-see-drafts SELECT policy alongside the public-read policy\r\n11. **Use `(select auth.uid())`** instead of bare `auth.uid()` for better query performance on large tables\r\n12. **Use `TO authenticated` or `TO anon`** to specify which roles a policy applies to\r\n13. **For multi-table schemas with foreign keys**: ALWAYS create a `SECURITY DEFINER` helper function (Pattern 8). NEVER write policies with direct cross-table subqueries (e.g., `SELECT id FROM workspaces` inside a projects policy). Direct subqueries cause `relation does not exist` errors or infinite recursion. This is MANDATORY for any schema with 3+ tables.\r\n14. **schema.sql section order**: ALL CREATE TABLE first → helper functions → ALL ALTER TABLE ENABLE RLS → ALL policies (DO $$ IF NOT EXISTS) → ALL indexes. NEVER interleave table creation with policy creation.\r\n15. **NEVER use bare `CREATE POLICY` or `DROP POLICY IF EXISTS`** — always use the `DO $$ BEGIN IF NOT EXISTS ... END $$;` pattern for idempotent, re-runnable schemas.\r\n16. **ALWAYS end schema.sql with `NOTIFY pgrst, 'reload schema';`** — this forces PostgREST to detect new tables immediately. Without it, the API may return \"table not found\" for up to 2 minutes after table creation.\r\n17. **Write SQL in lowercase** — Supabase convention. Use lowercase for all SQL keywords: `create table`, `select`, `insert`, etc. (Policy names in double quotes remain mixed case.)\r\n18. **Prefer PERMISSIVE policies** (the default) — avoid RESTRICTIVE unless you have a specific requirement. RESTRICTIVE policies combine with AND and cause unexpected access denials.\r\n19. **Always specify roles with TO** — use `to authenticated` or `to anon` on every policy. This prevents policies from running for roles that don't need them (e.g., `anon` users don't need authenticated-only policies).\r\n20. **Add indexes for every column used in RLS policies** — `user_id`, `workspace_id`, `team_id`, `project_id`, and any other FK columns referenced in USING/WITH CHECK clauses. Without indexes, RLS causes full table scans.\r\n21. **Minimize joins in policies** — use `column IN (SELECT ...)` pattern instead of joining the source table. This allows Postgres to optimize the subquery independently.",
  },
  "route-planning": {
    name: "route-planning",
    description: "Plan pages, API routes, navigation structure, and page blueprints for complex layouts. Use when designing app navigation and page structure.",
    category: "architecture",
    agents: ["architecture"],
    instructions: "## When to Use\r\n- Defining app routes and navigation\r\n- Planning landing pages with multiple sections\r\n- Creating page blueprints for complex layouts\r\n\r\n## Instructions\r\n\r\n### ROUTES SECTION FORMAT\r\n\r\n```\r\nROUTES:\r\n- / (homepage - main landing or app entry)\r\n- /dashboard (user's main view)\r\n- /settings (user preferences)\r\n- /[id] (dynamic route for items)\r\n```\r\n\r\n### PAGE_BLUEPRINT (for complex pages)\r\n\r\nUse PAGE_BLUEPRINT when a page has 3+ content sections (landing pages, marketing pages, dashboards).\r\n\r\n```\r\nPAGE_BLUEPRINT:\r\n  /:\r\n    sections:\r\n      - type: hero-centered\r\n        component: HeroSection\r\n        data: { headline: \"Your Headline\", subheadline: \"Supporting text\", cta_text: \"Get Started\", cta_href: \"#pricing\" }\r\n      - type: features-grid\r\n        component: FeaturesGrid\r\n        data: { features: [{ icon: \"Zap\", title: \"Fast\", description: \"Lightning speed\" }] }\r\n    flow: \"hero -> features -> footer\"\r\n```\r\n\r\n### COMPONENT TEMPLATES (section types)\r\n\r\n| Type | Description | Typical Data |\r\n|------|-------------|--------------|\r\n| hero-centered | Full-height centered hero | headline, subheadline, cta_text, cta_href |\r\n| hero-split | Two-column with content left, visual right | headline, description, image, cta |\r\n| features-grid | 3-column icon + title + description cards | features array |\r\n| features-alternating | Left-right alternating sections | features with images |\r\n| pricing-cards | 3-tier pricing with recommended highlight | plans array |\r\n| testimonials-carousel | Customer quote cards | testimonials array |\r\n\r\n### PAGE BLUEPRINT RULES\r\n1. Generate PAGE_BLUEPRINT ONLY for pages with 3+ content sections\r\n2. Skip for simple apps (todo, calculator, single-feature apps)\r\n3. Each section type must match a template above OR use descriptive custom type\r\n4. Each component MUST match a name in COMPONENTS list\r\n5. Data = props contract with CONCRETE EXAMPLE VALUES (not just type names)\r\n6. Flow = narrative arrow sequence of section reading order\r\n7. Keep data contracts minimal - only essential props",
  },
  "shadcn-components": {
    name: "shadcn-components",
    description: "Use shadcn/ui components correctly. CRITICAL - SelectItem value must be non-empty string. All components are PRE-INSTALLED — just import them, never recreate.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Using any shadcn/ui component\r\n- Creating forms with Select components\r\n- Building dialogs, cards, or modals\r\n- Need to know what components are available\r\n\r\n## Instructions\r\n\r\n### ALL Components Are PRE-INSTALLED\r\n\r\nThe sandbox template installs ALL shadcn/ui components. **DO NOT create files in components/ui/**.\r\nJust import what you need:\r\n\r\n```tsx\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from \"@/components/ui/card\"\r\nimport { Input } from \"@/components/ui/input\"\r\nimport { Label } from \"@/components/ui/label\"\r\nimport { Textarea } from \"@/components/ui/textarea\"\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\r\nimport { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger, DialogFooter } from \"@/components/ui/dialog\"\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\"\r\nimport { Badge } from \"@/components/ui/badge\"\r\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\r\nimport { Checkbox } from \"@/components/ui/checkbox\"\r\nimport { Switch } from \"@/components/ui/switch\"\r\nimport { Separator } from \"@/components/ui/separator\"\r\nimport { ScrollArea } from \"@/components/ui/scroll-area\"\r\nimport { Skeleton } from \"@/components/ui/skeleton\"\r\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuSeparator } from \"@/components/ui/dropdown-menu\"\r\n```\r\n\r\n`lib/utils.ts` with the `cn()` function is also pre-installed. Do NOT recreate it.\r\n\r\n### Styling with Tailwind Theme Classes\r\n\r\nComponents automatically use the app's design tokens via Tailwind theme classes:\r\n\r\n| Purpose | Tailwind Class | Maps to CSS Variable |\r\n|---------|---------------|---------------------|\r\n| Primary background | `bg-primary` | `--primary` |\r\n| Primary text | `text-primary` | `--primary` |\r\n| Text on primary bg | `text-primary-foreground` | `--primary-foreground` |\r\n| Page background | `bg-background` | `--background` |\r\n| Main text | `text-foreground` | `--foreground` |\r\n| Card background | `bg-card` | `--card` |\r\n| Card text | `text-card-foreground` | `--card-foreground` |\r\n| Muted background | `bg-muted` | `--muted` |\r\n| Subtle text | `text-muted-foreground` | `--muted-foreground` |\r\n| Accent background | `bg-accent` | `--accent` |\r\n| Border | `border-border` | `--border` |\r\n| Destructive | `bg-destructive` | `--destructive` |\r\n\r\n**NEVER use explicit CSS variable syntax (e.g., bg-[var(--varname)]). Use the Tailwind theme classes above.**\r\n\r\n### ⚠️ Select Component (CRITICAL - VIOLATIONS CRASH THE APP)\r\n\r\nThe Select component has strict rules that MUST be followed:\r\n\r\n```tsx\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\r\n\r\n// ✅ CORRECT - Static options with non-empty values\r\n<Select value={status} onValueChange={setStatus}>\r\n  <SelectTrigger className=\"w-full\">\r\n    <SelectValue placeholder=\"Select status\" />\r\n  </SelectTrigger>\r\n  <SelectContent>\r\n    <SelectItem value=\"todo\">To Do</SelectItem>\r\n    <SelectItem value=\"in-progress\">In Progress</SelectItem>\r\n    <SelectItem value=\"done\">Done</SelectItem>\r\n  </SelectContent>\r\n</Select>\r\n```\r\n\r\n**5 SELECT RULES (memorize these):**\r\n\r\n| Rule | Wrong | Correct |\r\n|------|-------|---------|\r\n| 1. Never empty value | `value=\"\"` | `value=\"none\"` |\r\n| 2. Use \"none\" for optional | `value=\"\"` | `value=\"none\"` |\r\n| 3. Filter empty IDs | `item?.id` | `.filter(item => item.id && item.id.trim() !== \"\")` |\r\n| 4. No optional chaining | `value={item?.id}` | `value={item.id}` |\r\n| 5. Use fallback | `value={item.id}` | `value={item.id \\|\\| \"none\"}` |\r\n\r\n**Dynamic options with validation:**\r\n\r\n```tsx\r\n// ✅ CORRECT - Filter and validate before mapping\r\n<Select value={epicId || \"none\"} onValueChange={setEpicId}>\r\n  <SelectTrigger>\r\n    <SelectValue placeholder=\"Select epic\" />\r\n  </SelectTrigger>\r\n  <SelectContent>\r\n    <SelectItem value=\"none\">No Epic</SelectItem>\r\n    {epics.filter(epic => epic.id && epic.id.trim() !== \"\").map(epic => (\r\n      <SelectItem key={epic.id} value={epic.id}>{epic.name}</SelectItem>\r\n    ))}\r\n  </SelectContent>\r\n</Select>\r\n```\r\n\r\n### RULES\r\n\r\n1. **NEVER create files in components/ui/** — they are pre-installed\r\n2. **NEVER recreate lib/utils.ts** — it's pre-installed with cn()\r\n3. **SelectItem value MUST be non-empty** — use \"none\" for optional selections\r\n4. **Always filter dynamic arrays** before mapping to SelectItems\r\n5. **Import from @/components/ui/** — not from radix directly\r\n6. **Use asChild on triggers** — when wrapping custom elements\r\n7. **Use cn() for conditional classes** — import from @/lib/utils\r\n8. **Use Tailwind theme classes** — bg-primary, text-foreground, bg-card, etc.",
  },
  "state-management": {
    name: "state-management",
    description: "Manage component and app state in React. Use when deciding between useState, useReducer, Context, or zustand. CRITICAL - never use useSyncExternalStore.",
    category: "frontend",
    agents: ["coder","chat"],
    instructions: "## When to Use\r\n- Managing local component state\r\n- Sharing state across components\r\n- Deciding which state solution to use\r\n- Fixing \"getServerSnapshot should be cached\" errors\r\n\r\n## Instructions\r\n\r\n### State Management Decision Tree\r\n\r\n```\r\nNeed state? → Is it local to one component?\r\n              ├── YES → useState (90% of cases)\r\n              └── NO → Is it shared across 2-3 components?\r\n                       ├── YES → Prop drilling or Context + useState\r\n                       └── NO → Is zustand in PACKAGES?\r\n                                ├── YES → zustand\r\n                                └── NO → Context + useState\r\n```\r\n\r\n### Priority Order (Use First Available)\r\n\r\n1. **useState** — sufficient for 90% of apps (PREFERRED)\r\n2. **useReducer** — complex state with many actions\r\n3. **Context + useState** — shared state across components\r\n4. **zustand** — ONLY if architecture.md PACKAGES lists it\r\n\r\n### ⚠️ NEVER USE useSyncExternalStore\r\n\r\n**NEVER create custom stores with useSyncExternalStore — causes SSR hydration errors.**\r\n\r\n```tsx\r\n// ❌ WRONG - causes \"getServerSnapshot should be cached\" error\r\nimport { useSyncExternalStore } from 'react'\r\n\r\nconst store = {\r\n  state: [],\r\n  listeners: new Set(),\r\n  subscribe(listener) { ... },\r\n  getSnapshot() { ... },\r\n  getServerSnapshot() { ... }\r\n}\r\n\r\nexport function useStore() {\r\n  return useSyncExternalStore(\r\n    store.subscribe,\r\n    store.getSnapshot,\r\n    store.getServerSnapshot // This pattern causes SSR errors!\r\n  )\r\n}\r\n```\r\n\r\n### useState Pattern (Use This First)\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useState } from 'react'\r\n\r\ninterface Todo {\r\n  id: string\r\n  text: string\r\n  completed: boolean\r\n}\r\n\r\nconst INITIAL_TODOS: Todo[] = [\r\n  { id: '1', text: 'Learn React', completed: true },\r\n  { id: '2', text: 'Build app', completed: false },\r\n]\r\n\r\nexport function TodoList() {\r\n  const [todos, setTodos] = useState(INITIAL_TODOS)\r\n\r\n  const addTodo = (text: string) => {\r\n    setTodos(prev => [...prev, {\r\n      id: `todo-${prev.length + 1}`,\r\n      text,\r\n      completed: false\r\n    }])\r\n  }\r\n\r\n  const toggleTodo = (id: string) => {\r\n    setTodos(prev =>\r\n      prev.map(todo =>\r\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\r\n      )\r\n    )\r\n  }\r\n\r\n  const deleteTodo = (id: string) => {\r\n    setTodos(prev => prev.filter(todo => todo.id !== id))\r\n  }\r\n\r\n  return (\r\n    <ul>\r\n      {todos.map(todo => (\r\n        <li key={todo.id}>\r\n          <span\r\n            style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\r\n            onClick={() => toggleTodo(todo.id)}\r\n          >\r\n            {todo.text}\r\n          </span>\r\n          <button onClick={() => deleteTodo(todo.id)}>Delete</button>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n```\r\n\r\n### Context + useState Pattern (Shared State)\r\n\r\n```tsx\r\n// lib/store.tsx\r\n'use client'\r\n\r\nimport { createContext, useContext, useState, ReactNode } from 'react'\r\n\r\ninterface AppState {\r\n  user: string | null\r\n  theme: 'light' | 'dark'\r\n}\r\n\r\ninterface AppContextType {\r\n  state: AppState\r\n  setUser: (user: string | null) => void\r\n  toggleTheme: () => void\r\n}\r\n\r\nconst AppContext = createContext<AppContextType | null>(null)\r\n\r\nexport function AppProvider({ children }: { children: ReactNode }) {\r\n  const [state, setState] = useState<AppState>({\r\n    user: null,\r\n    theme: 'light',\r\n  })\r\n\r\n  const setUser = (user: string | null) => {\r\n    setState(prev => ({ ...prev, user }))\r\n  }\r\n\r\n  const toggleTheme = () => {\r\n    setState(prev => ({\r\n      ...prev,\r\n      theme: prev.theme === 'light' ? 'dark' : 'light'\r\n    }))\r\n  }\r\n\r\n  return (\r\n    <AppContext.Provider value={{ state, setUser, toggleTheme }}>\r\n      {children}\r\n    </AppContext.Provider>\r\n  )\r\n}\r\n\r\nexport function useApp() {\r\n  const context = useContext(AppContext)\r\n  if (!context) {\r\n    throw new Error('useApp must be used within AppProvider')\r\n  }\r\n  return context\r\n}\r\n```\r\n\r\n**Usage in layout.tsx:**\r\n\r\n```tsx\r\n// app/layout.tsx\r\nimport { AppProvider } from '@/lib/store'\r\n\r\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>\r\n        <AppProvider>\r\n          {children}\r\n        </AppProvider>\r\n      </body>\r\n    </html>\r\n  )\r\n}\r\n```\r\n\r\n### useReducer Pattern (Complex State)\r\n\r\n```tsx\r\n'use client'\r\n\r\nimport { useReducer } from 'react'\r\n\r\ninterface State {\r\n  count: number\r\n  step: number\r\n  history: number[]\r\n}\r\n\r\ntype Action =\r\n  | { type: 'increment' }\r\n  | { type: 'decrement' }\r\n  | { type: 'setStep'; step: number }\r\n  | { type: 'reset' }\r\n\r\nconst initialState: State = {\r\n  count: 0,\r\n  step: 1,\r\n  history: [0],\r\n}\r\n\r\nfunction reducer(state: State, action: Action): State {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      const newCount = state.count + state.step\r\n      return { ...state, count: newCount, history: [...state.history, newCount] }\r\n    case 'decrement':\r\n      const decremented = state.count - state.step\r\n      return { ...state, count: decremented, history: [...state.history, decremented] }\r\n    case 'setStep':\r\n      return { ...state, step: action.step }\r\n    case 'reset':\r\n      return initialState\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\nexport function Counter() {\r\n  const [state, dispatch] = useReducer(reducer, initialState)\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {state.count}</p>\r\n      <button onClick={() => dispatch({ type: 'increment' })}>+{state.step}</button>\r\n      <button onClick={() => dispatch({ type: 'decrement' })}>-{state.step}</button>\r\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### zustand Pattern (Only if in PACKAGES)\r\n\r\n```tsx\r\n// lib/store.ts\r\nimport { create } from 'zustand'\r\n\r\ninterface TodoStore {\r\n  todos: Todo[]\r\n  addTodo: (text: string) => void\r\n  toggleTodo: (id: string) => void\r\n  deleteTodo: (id: string) => void\r\n}\r\n\r\nexport const useTodoStore = create<TodoStore>((set) => ({\r\n  todos: [\r\n    { id: '1', text: 'Learn zustand', completed: false },\r\n  ],\r\n  addTodo: (text) =>\r\n    set((state) => ({\r\n      todos: [...state.todos, { id: `${state.todos.length + 1}`, text, completed: false }]\r\n    })),\r\n  toggleTodo: (id) =>\r\n    set((state) => ({\r\n      todos: state.todos.map((todo) =>\r\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\r\n      )\r\n    })),\r\n  deleteTodo: (id) =>\r\n    set((state) => ({\r\n      todos: state.todos.filter((todo) => todo.id !== id)\r\n    })),\r\n}))\r\n```\r\n\r\n### Fixing \"getServerSnapshot should be cached\" Error\r\n\r\nIf you see this error, the code uses useSyncExternalStore incorrectly. **Replace with useState or Context:**\r\n\r\n1. Remove any `useSyncExternalStore` imports\r\n2. Remove custom subscribe/getSnapshot/getServerSnapshot functions\r\n3. Replace with useState or Context + useState pattern\r\n4. Update all components using the store\r\n\r\n### RULES\r\n\r\n1. **useState first** — sufficient for 90% of apps\r\n2. **NEVER useSyncExternalStore** — causes SSR hydration errors\r\n3. **NEVER create lib/store.ts with custom subscribe/getSnapshot patterns**\r\n4. **Context for shared state** — when 3+ components need same state\r\n5. **zustand ONLY if in PACKAGES** — handles SSR correctly\r\n6. **Initialize state correctly** — with demo data for static/non-DB components; with empty array `[]` + loading state for components that fetch from database (data loads via useEffect)",
  },
  "tailwind-v4": {
    name: "tailwind-v4",
    description: "Tailwind CSS v4 patterns — @import syntax, CSS variables, custom variants. CRITICAL — wrong syntax breaks build. Use when writing globals.css, adding styles, or fixing CSS errors.",
    category: "shared",
    agents: ["all"],
    instructions: "## When to Use\r\n- Writing or modifying globals.css\r\n- Adding CSS variables or design tokens\r\n- Fixing CSS build errors (\"@import rules must precede\", \"is not exported\")\r\n- Working with Tailwind utility classes and CSS variables\r\n- Setting up dark mode with custom variants\r\n\r\n## Instructions\r\n\r\n### Tailwind v4 vs v3 (CRITICAL DIFFERENCES)\r\n\r\nThis project uses **Tailwind CSS v4**, which is very different from v3:\r\n\r\n1. **globals.css MUST start with**: `@import \"tailwindcss\";` — this is the ONLY import needed\r\n2. **NEVER use v3 syntax**: No `@tailwind base`, `@tailwind components`, `@tailwind utilities`\r\n3. **NEVER use `@import url(...)`** for fonts in CSS — this breaks the build\r\n4. **Load fonts via `next/font/google`** in layout.tsx, NOT via CSS imports\r\n5. **Custom variants**: Use `@custom-variant dark (&:where(.dark, .dark *));` for dark mode\r\n\r\n### Tailwind v4 Opacity Syntax (CRITICAL)\r\n\r\nTailwind v4 removed separate opacity utilities. Use **slash syntax**:\r\n\r\n| v3 (WRONG — will error) | v4 (CORRECT) |\r\n|--------------------------|--------------|\r\n| `bg-black bg-opacity-50` | `bg-black/50` |\r\n| `text-white text-opacity-75` | `text-white/75` |\r\n| `border-gray-300 border-opacity-50` | `border-gray-300/50` |\r\n| `bg-primary bg-opacity-20` | `bg-primary/20` |\r\n\r\n**NEVER use `bg-opacity-*`, `text-opacity-*`, or `border-opacity-*`** — these do not exist in v4.\r\n\r\n### globals.css Template (shadcn + Tailwind v4)\r\n\r\n```css\r\n@import \"tailwindcss\";\r\n\r\n@custom-variant dark (&:where(.dark, .dark *));\r\n\r\n:root {\r\n  --font-display: 'Font Name', serif;\r\n  --font-body: 'Font Name', sans-serif;\r\n  --radius: 0.5rem;\r\n  --background: #ffffff;\r\n  --foreground: #0f172a;\r\n  --card: #f8fafc;\r\n  --card-foreground: #0f172a;\r\n  --popover: #f8fafc;\r\n  --popover-foreground: #0f172a;\r\n  --primary: #6366f1;\r\n  --primary-foreground: #ffffff;\r\n  --secondary: #f1f5f9;\r\n  --secondary-foreground: #0f172a;\r\n  --muted: #f1f5f9;\r\n  --muted-foreground: #64748b;\r\n  --accent: #f59e0b;\r\n  --accent-foreground: #ffffff;\r\n  --destructive: #ef4444;\r\n  --destructive-foreground: #ffffff;\r\n  --border: #e2e8f0;\r\n  --input: #e2e8f0;\r\n  --ring: #6366f1;\r\n}\r\n\r\n.dark {\r\n  --background: #0f172a;\r\n  --foreground: #f8fafc;\r\n  /* ... dark mode overrides for all variables ... */\r\n}\r\n\r\n@theme inline {\r\n  --color-background: var(--background);\r\n  --color-foreground: var(--foreground);\r\n  --color-card: var(--card);\r\n  --color-card-foreground: var(--card-foreground);\r\n  --color-popover: var(--popover);\r\n  --color-popover-foreground: var(--popover-foreground);\r\n  --color-primary: var(--primary);\r\n  --color-primary-foreground: var(--primary-foreground);\r\n  --color-secondary: var(--secondary);\r\n  --color-secondary-foreground: var(--secondary-foreground);\r\n  --color-muted: var(--muted);\r\n  --color-muted-foreground: var(--muted-foreground);\r\n  --color-accent: var(--accent);\r\n  --color-accent-foreground: var(--accent-foreground);\r\n  --color-destructive: var(--destructive);\r\n  --color-destructive-foreground: var(--destructive-foreground);\r\n  --color-border: var(--border);\r\n  --color-input: var(--input);\r\n  --color-ring: var(--ring);\r\n  --radius-sm: calc(var(--radius) - 4px);\r\n  --radius-md: calc(var(--radius) - 2px);\r\n  --radius-lg: var(--radius);\r\n  --radius-xl: calc(var(--radius) + 4px);\r\n}\r\n\r\n.font-display { font-family: var(--font-display); }\r\n.font-body { font-family: var(--font-body); }\r\n\r\n@layer base {\r\n  body {\r\n    @apply bg-background text-foreground;\r\n  }\r\n}\r\n```\r\n\r\n### Design System CSS Variables\r\n\r\nThis app uses shadcn's native CSS variable system. The key variables are:\r\n\r\n- `--primary` — brand/accent color for buttons, links, highlights\r\n- `--accent` — secondary accent color\r\n- `--background` — page background\r\n- `--card` — card/section backgrounds (previously `--color-surface`)\r\n- `--foreground` — main text color (previously `--color-text`)\r\n- `--muted-foreground` — secondary/subtle text (previously `--color-muted`)\r\n- `--font-display` / `--font-body` — fonts stay the same\r\n\r\n### Tailwind Theme Class Usage in Components\r\n\r\n```tsx\r\n<div className=\"min-h-screen bg-background\">\r\n  <h1 className=\"font-display text-4xl text-foreground\">Title</h1>\r\n  <button className=\"bg-primary text-primary-foreground\">Action</button>\r\n  <p className=\"text-muted-foreground\">Subtext</p>\r\n  <div className=\"bg-card rounded-xl p-4\">Card</div>\r\n</div>\r\n```\r\n\r\nTailwind theme classes reference:\r\n```\r\nbg-background          — page background\r\nbg-card                — card background\r\ntext-foreground        — main text\r\ntext-muted-foreground  — subtle text\r\ntext-primary           — accent text\r\nbg-primary             — accent background\r\nborder-border          — default border\r\nborder-primary         — accent border\r\n```\r\n\r\n**NEVER use bg-white, text-black, bg-gray-*. Always use Tailwind theme classes.**\r\n\r\n### CSS Build Errors\r\n\r\n**\"is not exported\" or \"@import rules must precede all rules\"** errors mean:\r\n1. Wrong Tailwind syntax, OR\r\n2. @import url() used incorrectly\r\n\r\n**Fix:**\r\n```css\r\n/* ❌ WRONG - old v3 syntax */\r\n@import \"tailwindcss/base\";\r\n@import \"tailwindcss/components\";\r\n@import \"tailwindcss/utilities\";\r\n\r\n/* ❌ WRONG - font @import after tailwind */\r\n@import \"tailwindcss\";\r\n/* ...tailwind expands here... */\r\n@import url('https://fonts.googleapis.com/...');\r\n\r\n/* ✅ CORRECT - only this ONE import */\r\n@import \"tailwindcss\";\r\n\r\n:root {\r\n  /* CSS variables here */\r\n}\r\n```\r\n\r\n**Font Loading:** Use `next/font/google` in layout.tsx, NOT @import url() in CSS.\r\n\r\n### RULES CHECKLIST\r\n\r\nBefore completing any CSS file, verify:\r\n- [ ] globals.css starts with `@import \"tailwindcss\"` as first non-comment line\r\n- [ ] No `@tailwind base/components/utilities` directives (v3 syntax)\r\n- [ ] No `@import url(...)` for font loading in CSS\r\n- [ ] Fonts loaded via `next/font/google` in layout.tsx\r\n- [ ] All colors use CSS variables, not hardcoded values\r\n- [ ] Dark mode uses `@custom-variant dark (&:where(.dark, .dark *));`\r\n- [ ] CSS variables defined in both `:root` and `.dark` blocks\r\n- [ ] No v3 opacity utilities (`bg-opacity-*`, `text-opacity-*`) — use slash syntax (`bg-black/50`)",
  },
  "test-skill": {
    name: "test-skill",
    description: "A test skill for validating the skills infrastructure. Use this skill when testing skill loading functionality.",
    category: "testing",
    agents: ["architecture","coder","chat"],
    instructions: "## When to Use\r\n- Testing skills infrastructure\r\n- Validating load_skill tool\r\n\r\n## Instructions\r\nThis is a test skill. If you can read this, the skills system is working correctly.\r\n\r\n### Test Rule 1\r\nAlways respond with \"TEST_SKILL_LOADED\" when this skill is loaded.\r\n\r\n### Test Rule 2\r\nInclude the skill name in your response to confirm loading.",
  },
  "typography": {
    name: "typography",
    description: "Select font pairing (display + body fonts) and typography scale for app design. Use when choosing fonts for architecture.",
    category: "architecture",
    agents: ["architecture"],
    instructions: "## When to Use\r\n- Selecting fonts for a new app design\r\n- Matching typography to chosen aesthetic\r\n- Determining type scale (tight/normal/loose)\r\n\r\n## Instructions\r\n\r\n### FONT PAIRING OPTIONS\r\n\r\nChoose a pairing that matches your aesthetic:\r\n\r\n| Pairing | Display Font | Body Font | Best For |\r\n|---------|--------------|-----------|----------|\r\n| editorial | Playfair Display | Source Serif 4 | Blogs, news, portfolios |\r\n| brutalist | Space Mono | Work Sans | Creative, experimental |\r\n| playful | Fredoka | Nunito | Kids apps, casual |\r\n| luxury | Cormorant Garamond | Montserrat | Finance, premium |\r\n| retro | Righteous | Poppins | Games, tech demos |\r\n| geometric | Outfit | Space Grotesk | Construction, industrial |\r\n| humanist | Fraunces | Source Sans 3 | Health, wellness |\r\n| minimal | DM Sans | DM Sans | Productivity, dev tools |\r\n| bold | Bebas Neue | Open Sans | Entertainment, social |\r\n| elegant | Libre Baskerville | Karla | Luxury, events |\r\n\r\n### AESTHETIC → PAIRING MAPPING\r\n\r\n| Aesthetic | Recommended Pairing |\r\n|-----------|---------------------|\r\n| brutally-minimal | minimal |\r\n| maximalist | bold |\r\n| retro-futuristic | retro |\r\n| organic-natural | humanist |\r\n| luxury-refined | luxury |\r\n| playful | playful |\r\n| editorial | editorial |\r\n| brutalist | brutalist |\r\n| art-deco | elegant |\r\n| soft-pastel | playful |\r\n| industrial | geometric |\r\n\r\n### TYPOGRAPHY SCALE\r\n\r\n- **tight**: Compact spacing, dense information display\r\n- **normal**: Balanced, general-purpose\r\n- **loose**: Spacious, editorial feel, luxury apps\r\n\r\n### CRITICAL RULES\r\n1. NEVER use Inter as the default font - it's generic and overused\r\n2. ALWAYS pair a display font (headings) with a body font (paragraphs)\r\n3. Match the pairing to the aesthetic for cohesive design\r\n4. All fonts must be Google Fonts (available for free)",
  },
  "understand-request": {
    name: "understand-request",
    description: "ROUTER SKILL — Always load first. Analyzes user's modification intent and recommends which skills to load next. Use before any code changes.",
    category: "chat",
    agents: ["chat"],
    instructions: "## When to Use\r\n- ALWAYS load this skill first when receiving a chat modification request\r\n- Before making any code changes\r\n\r\n## Instructions\r\n\r\n### Request Analysis Framework\r\n\r\nWhen you receive a user's modification request, classify it:\r\n\r\n| Intent Type | Indicators | Recommended Skills |\r\n|-------------|------------|-------------------|\r\n| Visual/Styling change | \"change color\", \"make bigger\", \"move\", \"hide\", \"style\" | `edit-component`, `react-component` |\r\n| Visual bug / not visible | \"can't see\", \"invisible\", \"wrong color\", \"text not showing\" | `debug-visual-issues`, `edit-component` |\r\n| Functional bug | \"not working\", \"error\", \"broken\", \"crash\" | `fix-bug` |\r\n| Add new feature | \"add\", \"create\", \"implement\", \"new\" | `add-feature`, `react-component` |\r\n| Layout change | \"layout\", \"grid\", \"responsive\", \"mobile\" | `edit-component`, `layout-grid`, `responsive-design` |\r\n| Form handling | \"form\", \"input\", \"validation\", \"submit\" | `add-feature`, `form-builder` |\r\n| Animation | \"animate\", \"transition\", \"hover effect\" | `edit-component`, `animation` |\r\n| Explain | \"explain\", \"how does\", \"what does\", \"why\" | `explain-code` |\r\n| State/Data | \"state\", \"data\", \"fetch\", \"store\" | `add-feature`, `state-management` |\r\n| Database | \"save\", \"persist\", \"database\", \"supabase\" | `add-feature`, `database-queries` |\r\n| Schema change | \"add column\", \"add field\", \"add table\", \"new table\", \"modify schema\", \"fix RLS\", \"add policy\", \"drop column\", \"remove field\" | `modify-schema`, `rls-policies`, `database-queries` |\r\n\r\n### Workflow\r\n1. Read user message\r\n2. Classify intent (may be multiple types)\r\n3. Load recommended skills from table above\r\n4. Then proceed with the actual task using loaded skill guidance",
  }
};
